<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sheep Herder Co-op</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- PeerJS for Networking -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1c1917; /* stone-900 */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: none; /* Prevent pull-to-refresh on mobile */
      }
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; }
      ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "peerjs": "https://aistudiocdn.com/peerjs@^1.5.5",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // --- ICONS (Inline SVGs to avoid dependencies) ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const User = (props) => <IconWrapper {...props}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconWrapper>;
        const Users = (props) => <IconWrapper {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconWrapper>;
        const Copy = (props) => <IconWrapper {...props}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></IconWrapper>;
        const Play = (props) => <IconWrapper {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconWrapper>;
        const Info = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></IconWrapper>;
        const Loader2 = ({ className, ...props }) => <IconWrapper className={`animate-spin ${className}`} {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconWrapper>;
        const RotateCcw = (props) => <IconWrapper {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconWrapper>;

        // --- CONSTANTS & TYPES ---
        const PlayerColor = {
            GREEN: '#22c55e',
            PINK: '#ec4899',
            PURPLE: '#a855f7',
            BLACK: '#171717',
        };

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const PLAYER_SPEED = 5;
        const SHEEP_SPEED = 2.5;
        const SHEEP_FLEE_RADIUS = 200;
        const PEN_RECT = { x: 50, y: 50, w: 250, h: 200 };

        const INITIAL_GAME_STATE = {
            players: [],
            sheep: [],
            gameStatus: 'LOBBY',
            timer: 0,
            totalSheep: 10,
            sheepInPen: 0,
        };

        const AVAILABLE_COLORS = [
            { label: 'Green', value: PlayerColor.GREEN, bg: 'bg-green-500' },
            { label: 'Pink', value: PlayerColor.PINK, bg: 'bg-pink-500' },
            { label: 'Purple', value: PlayerColor.PURPLE, bg: 'bg-purple-500' },
            { label: 'Black', value: PlayerColor.BLACK, bg: 'bg-neutral-900' },
        ];

        // --- GAME LOGIC ---
        const checkCollision = (r1, r2) => {
            return (
                r1.x < r2.x + r2.w &&
                r1.x + r1.w > r2.x &&
                r1.y < r2.y + r2.h &&
                r1.y + r1.h > r2.y
            );
        };

        const distance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        const generateSheep = (count) => {
            const sheep = [];
            for(let i=0; i<count; i++) {
                sheep.push({
                    id: `sheep-${i}-${Date.now()}`,
                    x: CANVAS_WIDTH / 2 + (Math.random() * 400 - 200),
                    y: CANVAS_HEIGHT / 2 + (Math.random() * 400 - 200),
                    vx: 0,
                    vy: 0,
                    isCarried: false,
                    inPen: false,
                    carriedByPlayerId: null
                });
            }
            return sheep;
        };

        const updatePhysics = (gameState, inputs) => {
            const newState = { ...gameState };

            // 1. Update Players
            newState.players = newState.players.map(player => {
                const input = inputs[player.peerId];
                if (!input) return player;

                let dx = 0;
                let dy = 0;

                if (input.up) dy -= PLAYER_SPEED;
                if (input.down) dy += PLAYER_SPEED;
                if (input.left) dx -= PLAYER_SPEED;
                if (input.right) dx += PLAYER_SPEED;

                if (dx !== 0 && dy !== 0) {
                    dx *= 0.7071;
                    dy *= 0.7071;
                }

                let newX = Math.max(20, Math.min(CANVAS_WIDTH - 20, player.x + dx));
                let newY = Math.max(20, Math.min(CANVAS_HEIGHT - 20, player.y + dy));

                // Action: Pick up / Drop
                let holdingSheepId = player.holdingSheepId;
                
                if (input.action) {
                    if (holdingSheepId) {
                        const sheepIndex = newState.sheep.findIndex(s => s.id === holdingSheepId);
                        if (sheepIndex !== -1) {
                            newState.sheep[sheepIndex].isCarried = false;
                            newState.sheep[sheepIndex].carriedByPlayerId = null;
                            holdingSheepId = null;
                        }
                    } else {
                        const closestSheep = newState.sheep.find(s => 
                            !s.isCarried && 
                            !s.inPen && 
                            distance(player.x, player.y, s.x, s.y) < 40
                        );
                        if (closestSheep) {
                            closestSheep.isCarried = true;
                            closestSheep.carriedByPlayerId = player.peerId;
                            holdingSheepId = closestSheep.id;
                        }
                    }
                }

                return { ...player, x: newX, y: newY, holdingSheepId };
            });

            // 2. Update Sheep
            let sheepInPenCount = 0;

            newState.sheep = newState.sheep.map(sheep => {
                if (sheep.inPen) {
                    sheepInPenCount++;
                    return sheep;
                }

                if (sheep.isCarried && sheep.carriedByPlayerId) {
                    const carrier = newState.players.find(p => p.peerId === sheep.carriedByPlayerId);
                    if (carrier) {
                        const inPen = checkCollision(
                            {x: carrier.x, y: carrier.y, w: 10, h: 10}, 
                            {x: PEN_RECT.x, y: PEN_RECT.y, w: PEN_RECT.w, h: PEN_RECT.h}
                        );
                        
                        return { ...sheep, x: carrier.x, y: carrier.y - 10, vx: 0, vy: 0 };
                    } else {
                        return { ...sheep, isCarried: false, carriedByPlayerId: null };
                    }
                }

                // AI: Flee
                let closestDist = Infinity;
                let targetPlayer = null;

                newState.players.forEach(p => {
                    const d = distance(sheep.x, sheep.y, p.x, p.y);
                    if (d < closestDist) {
                        closestDist = d;
                        targetPlayer = p;
                    }
                });

                let vx = 0;
                let vy = 0;

                if (targetPlayer && closestDist < SHEEP_FLEE_RADIUS) {
                    const angle = Math.atan2(sheep.y - targetPlayer.y, sheep.x - targetPlayer.x);
                    vx = Math.cos(angle) * SHEEP_SPEED;
                    vy = Math.sin(angle) * SHEEP_SPEED;
                } else {
                    vx = sheep.vx * 0.9;
                    vy = sheep.vy * 0.9;
                    if (Math.random() < 0.02) {
                        const angle = Math.random() * Math.PI * 2;
                        vx = Math.cos(angle) * (SHEEP_SPEED * 0.5);
                        vy = Math.sin(angle) * (SHEEP_SPEED * 0.5);
                    }
                }

                let newX = Math.max(20, Math.min(CANVAS_WIDTH - 20, sheep.x + vx));
                let newY = Math.max(20, Math.min(CANVAS_HEIGHT - 20, sheep.y + vy));

                const isNowInPen = checkCollision(
                    {x: newX, y: newY, w: 20, h: 20},
                    {x: PEN_RECT.x, y: PEN_RECT.y, w: PEN_RECT.w, h: PEN_RECT.h}
                );

                if (isNowInPen) {
                    sheepInPenCount++;
                    return { ...sheep, x: newX, y: newY, vx: 0, vy: 0, inPen: true };
                }

                return { ...sheep, x: newX, y: newY, vx, vy };
            });

            newState.sheepInPen = sheepInPenCount;

            if (sheepInPenCount === newState.totalSheep) {
                newState.gameStatus = 'GAME_OVER';
            }

            return newState;
        };

        // --- CANVAS COMPONENT ---
        const GameCanvas = ({ gameState, myPeerId }) => {
            const canvasRef = useRef(null);

            const drawSheep = (ctx, sheep) => {
                ctx.save();
                ctx.translate(sheep.x, sheep.y);

                if (sheep.isCarried) {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(0, 30, 10, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.translate(0, -5 + Math.sin(Date.now() / 100) * 2);
                } else {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath();
                    ctx.ellipse(0, 10, 12, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#F3F4F6';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                for(let i=0; i<6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * 10, Math.sin(angle) * 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = '#1F2937';
                ctx.beginPath();
                ctx.arc(8, -4, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(8, -8, 2, 4, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(9, -5, 1, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            };

            const drawPlayer = (ctx, player) => {
                ctx.save();
                ctx.translate(player.x, player.y);

                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, 0, -25);
                if (player.peerId === myPeerId) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(0, -35);
                    ctx.lineTo(-5, -45);
                    ctx.lineTo(5, -45);
                    ctx.fill();
                }

                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 15, 10, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'white';
                ctx.stroke();

                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.strokeStyle = player.color;

                if (player.holdingSheepId) {
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-15, -10);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(15, -10);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(-12, 5);
                    ctx.lineTo(-18, 10);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(12, 5);
                    ctx.lineTo(18, 10);
                    ctx.stroke();
                }

                ctx.restore();
            };

            const drawPen = (ctx) => {
                ctx.save();
                ctx.translate(PEN_RECT.x, PEN_RECT.y);
                
                ctx.fillStyle = '#d6b895';
                ctx.fillRect(0, 0, PEN_RECT.w, PEN_RECT.h);

                ctx.strokeStyle = '#5D4037';
                ctx.lineWidth = 5;
                ctx.strokeRect(0, 0, PEN_RECT.w, PEN_RECT.h);
                
                ctx.fillStyle = '#3E2723';
                [0, PEN_RECT.w].forEach(x => {
                    [0, PEN_RECT.h].forEach(y => {
                        ctx.fillRect(x - 5, y - 5, 10, 10);
                    });
                });

                ctx.fillStyle = 'rgba(93, 64, 55, 0.5)';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("PEN", PEN_RECT.w / 2, PEN_RECT.h / 2 + 10);

                ctx.restore();
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const render = () => {
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    ctx.fillStyle = '#86efac';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    ctx.fillStyle = '#4ade80';
                    for(let x=0; x<CANVAS_WIDTH; x+=100) {
                        for(let y=0; y<CANVAS_HEIGHT; y+=100) {
                            if ((x+y)%200 === 0) ctx.fillRect(x, y, 50, 50);
                        }
                    }

                    drawPen(ctx);

                    const entities = [
                        ...gameState.players.map(p => ({ type: 'player', y: p.y, obj: p })),
                        ...gameState.sheep.map(s => ({ type: 'sheep', y: s.y, obj: s }))
                    ];

                    entities.sort((a, b) => a.y - b.y);

                    entities.forEach(ent => {
                        if (ent.type === 'player') {
                            drawPlayer(ctx, ent.obj);
                        } else {
                            drawSheep(ctx, ent.obj);
                        }
                    });
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText(`Sheep Saved: ${gameState.sheepInPen} / ${gameState.totalSheep}`, 20, 30);

                    if (gameState.gameStatus === 'GAME_OVER') {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 60px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText("ALL SHEEP SAVED!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                        ctx.font = '24px Arial';
                        ctx.fillText("Great Teamwork!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
                    }
                };

                render();

            }, [gameState, myPeerId]);

            return (
                <canvas 
                ref={canvasRef} 
                width={CANVAS_WIDTH} 
                height={CANVAS_HEIGHT} 
                className="rounded-lg shadow-2xl cursor-crosshair touch-none"
                />
            );
        };

        // --- APP COMPONENT ---
        const App = () => {
            const [mode, setMode] = useState('MENU');
            const [myPeerId, setMyPeerId] = useState('');
            const [isHost, setIsHost] = useState(false);
            
            const [playerName, setPlayerName] = useState('');
            const [selectedColor, setSelectedColor] = useState(null);
            const [hostIdInput, setHostIdInput] = useState('');
            const [joinError, setJoinError] = useState('');
            const [isConnecting, setIsConnecting] = useState(false);

            const gameStateRef = useRef(JSON.parse(JSON.stringify(INITIAL_GAME_STATE)));
            const [renderedGameState, setRenderedGameState] = useState(INITIAL_GAME_STATE);
            
            const peerRef = useRef(null);
            const connectionsRef = useRef(new Map());
            const isHostRef = useRef(false);
            const hostIdRef = useRef('');
            const requestRef = useRef();
            
            const inputsRef = useRef({});
            const myInputRef = useRef({ up: false, down: false, left: false, right: false, action: false });
            const keysPressed = useRef(new Set());

            useEffect(() => {
                return () => {
                    if (peerRef.current) peerRef.current.destroy();
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, []);

            const initializePeer = async () => {
                return new Promise((resolve, reject) => {
                    const newPeer = new window.Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:global.stun.twilio.com:3478' }
                            ]
                        }
                    });
                    
                    newPeer.on('open', (id) => {
                        console.log('My peer ID is: ' + id);
                        setMyPeerId(id);
                        peerRef.current = newPeer;
                        resolve(newPeer);
                    });

                    newPeer.on('error', (err) => {
                        console.error('Peer error:', err);
                        setJoinError(`Connection error: ${err.type}`);
                        setIsConnecting(false);
                    });

                    newPeer.on('connection', (conn) => {
                        handleIncomingConnection(conn);
                    });
                });
            };

            const createGame = async () => {
                if (!playerName || !selectedColor) return;
                setIsConnecting(true);
                
                try {
                    const peer = await initializePeer();
                    setIsHost(true);
                    isHostRef.current = true;
                    setMode('LOBBY');

                    const hostPlayer = {
                        id: peer.id,
                        peerId: peer.id,
                        name: playerName,
                        color: selectedColor,
                        x: 100,
                        y: 100,
                        holdingSheepId: null,
                        isHost: true,
                        score: 0
                    };

                    gameStateRef.current = {
                        ...INITIAL_GAME_STATE,
                        players: [hostPlayer],
                        sheep: generateSheep(10)
                    };
                    setRenderedGameState({...gameStateRef.current});
                } catch (e) {
                    console.error(e);
                    setJoinError("Failed to initialize host");
                } finally {
                    setIsConnecting(false);
                }
            };

            const handleIncomingConnection = (conn) => {
                conn.on('open', () => {
                    console.log('New connection from:', conn.peer);
                    connectionsRef.current.set(conn.peer, conn);

                    conn.send({ type: 'GAME_STATE', payload: gameStateRef.current });

                    conn.on('data', (data) => {
                        handleNetworkMessage(conn.peer, data);
                    });

                    conn.on('close', () => {
                        connectionsRef.current.delete(conn.peer);
                        gameStateRef.current.players = gameStateRef.current.players.filter(p => p.peerId !== conn.peer);
                    });
                });
            };

            const startGame = () => {
                if (!isHost) return;
                gameStateRef.current.gameStatus = 'PLAYING';
                broadcast({ type: 'START_GAME', payload: {} });
                setMode('GAME');
            };

            const restartGame = () => {
                if (!isHostRef.current) return;
                const resetPlayers = gameStateRef.current.players.map((p, i) => ({
                    ...p,
                    x: 100 + (i * 100),
                    y: 100,
                    holdingSheepId: null,
                }));

                const newGameState = {
                    players: resetPlayers,
                    sheep: generateSheep(10),
                    gameStatus: 'PLAYING',
                    timer: 0,
                    totalSheep: 10,
                    sheepInPen: 0,
                };

                gameStateRef.current = newGameState;
                setRenderedGameState({...newGameState});
                broadcast({ type: 'GAME_STATE', payload: newGameState });
            };

            const joinGame = async () => {
                if (!playerName || !selectedColor || !hostIdInput) return;
                setIsConnecting(true);
                setJoinError('');

                try {
                    const peer = await initializePeer();
                    setIsHost(false);
                    isHostRef.current = false;
                    hostIdRef.current = hostIdInput;

                    const conn = peer.connect(hostIdInput);
                    
                    conn.on('open', () => {
                        connectionsRef.current.set(hostIdInput, conn);
                        conn.send({ 
                            type: 'JOIN_REQUEST', 
                            payload: { name: playerName, color: selectedColor } 
                        });
                    });

                    conn.on('data', (data) => {
                        if (data.type === 'GAME_STATE') {
                            gameStateRef.current = data.payload;
                            setRenderedGameState({...data.payload});
                            
                            if (mode === 'MENU') setMode('LOBBY');

                            if (data.payload.gameStatus === 'PLAYING' && mode !== 'GAME') {
                                setMode('GAME');
                            }
                        } else if (data.type === 'START_GAME') {
                            setMode('GAME');
                        } else if (data.type === 'JOIN_ACCEPT') {
                            setMode('LOBBY');
                        }
                    });

                    conn.on('error', (err) => {
                        setJoinError("Could not connect to host.");
                        setMode('MENU');
                        setIsConnecting(false);
                    });
                    
                    conn.on('close', () => {
                        alert("Disconnected from host");
                        window.location.reload();
                    });

                    setTimeout(() => {
                        if (connectionsRef.current.size === 0) {
                            setJoinError("Connection timed out.");
                            setIsConnecting(false);
                        }
                    }, 5000);

                } catch (e) {
                    setJoinError("Failed to initialize client");
                    setIsConnecting(false);
                }
            };

            const handleNetworkMessage = (senderId, msg) => {
                if (isHostRef.current) {
                    if (msg.type === 'JOIN_REQUEST') {
                        const { name, color } = msg.payload;
                        
                        if (gameStateRef.current.players.some(p => p.color === color)) {
                            console.warn(`Join rejected: Color taken`);
                            return; 
                        }

                        if (gameStateRef.current.players.length >= 4) return;

                        const newPlayer = {
                            id: senderId,
                            peerId: senderId,
                            name,
                            color,
                            x: 100 + (gameStateRef.current.players.length * 100),
                            y: 100,
                            holdingSheepId: null,
                            isHost: false,
                            score: 0
                        };
                        
                        gameStateRef.current.players.push(newPlayer);
                        broadcast({ type: 'GAME_STATE', payload: gameStateRef.current });
                    }
                    else if (msg.type === 'INPUT') {
                        inputsRef.current[senderId] = msg.payload;
                    }
                }
            };

            const broadcast = (msg) => {
                connectionsRef.current.forEach(conn => {
                    if (conn.open) conn.send(msg);
                });
            };

            const gameLoop = useCallback(() => {
                if (isHostRef.current) {
                    if (peerRef.current?.id) {
                        inputsRef.current[peerRef.current.id] = myInputRef.current;
                    }
                    
                    if (gameStateRef.current.gameStatus !== 'GAME_OVER') {
                        const nextState = updatePhysics(gameStateRef.current, inputsRef.current);
                        gameStateRef.current = nextState;
                    }

                    broadcast({ type: 'GAME_STATE', payload: gameStateRef.current });
                    setRenderedGameState({...gameStateRef.current});

                } else {
                    const hostId = hostIdRef.current;
                    const hostConn = connectionsRef.current.get(hostId);
                    if (hostConn && hostConn.open) {
                        hostConn.send({ type: 'INPUT', payload: myInputRef.current });
                    }
                }

                if (myInputRef.current.action) {
                    myInputRef.current.action = false;
                }
                
                Object.keys(inputsRef.current).forEach(k => {
                    if (inputsRef.current[k].action) inputsRef.current[k].action = false;
                });

                requestRef.current = requestAnimationFrame(gameLoop);
            }, []);

            useEffect(() => {
                if (mode === 'LOBBY' || mode === 'GAME') {
                    if (!requestRef.current) {
                        requestRef.current = requestAnimationFrame(gameLoop);
                    }
                } else {
                    if (requestRef.current) {
                        cancelAnimationFrame(requestRef.current);
                        requestRef.current = undefined;
                    }
                }
            }, [mode, gameLoop]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.repeat) return;
                    keysPressed.current.add(e.code);
                    updateInputState();
                };

                const handleKeyUp = (e) => {
                    keysPressed.current.delete(e.code);
                    updateInputState();
                };

                const updateInputState = () => {
                    const keys = keysPressed.current;
                    myInputRef.current = {
                        up: keys.has('ArrowUp') || keys.has('KeyW'),
                        down: keys.has('ArrowDown') || keys.has('KeyS'),
                        left: keys.has('ArrowLeft') || keys.has('KeyA'),
                        right: keys.has('ArrowRight') || keys.has('KeyD'),
                        action: keys.has('Space') || keys.has('Enter') || myInputRef.current.action
                    };
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, []);

            if (mode === 'MENU') {
                return (
                    <div className="min-h-screen bg-stone-100 flex items-center justify-center p-4">
                        <div className="max-w-md w-full bg-white rounded-xl shadow-xl p-8 space-y-6">
                        <div className="text-center space-y-2">
                            <h1 className="text-4xl font-bold text-stone-800">Sheep Herder</h1>
                            <p className="text-stone-500">Cooperative Multiplayer</p>
                        </div>

                        <div className="space-y-4">
                            <div>
                            <label className="block text-sm font-medium text-stone-700 mb-1">Your Name</label>
                            <input 
                                type="text" 
                                className="w-full p-2 border border-stone-300 rounded-md focus:ring-2 focus:ring-green-500 outline-none"
                                placeholder="Enter nickname"
                                value={playerName}
                                onChange={(e) => setPlayerName(e.target.value)}
                            />
                            </div>

                            <div>
                            <label className="block text-sm font-medium text-stone-700 mb-2">Select Color</label>
                            <div className="flex justify-between gap-2">
                                {AVAILABLE_COLORS.map(c => (
                                <button
                                    key={c.value}
                                    onClick={() => setSelectedColor(c.value)}
                                    className={`w-12 h-12 rounded-full ${c.bg} transition-transform hover:scale-110 ${selectedColor === c.value ? 'ring-4 ring-offset-2 ring-stone-400 scale-110' : ''}`}
                                    title={c.label}
                                />
                                ))}
                            </div>
                            </div>

                            <div className="pt-4 border-t border-stone-200 space-y-3">
                            {isConnecting ? (
                                <div className="flex justify-center py-4 text-green-600">
                                    <Loader2 className="animate-spin" size={32} />
                                </div>
                            ) : (
                                <>
                                    <button 
                                        onClick={createGame}
                                        disabled={!playerName || !selectedColor}
                                        className="w-full py-3 bg-green-600 text-white rounded-lg font-bold hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center gap-2"
                                    >
                                        <Play size={20} /> Create Host
                                    </button>
                                    
                                    <div className="relative">
                                        <div className="absolute inset-0 flex items-center"><div className="w-full border-t border-stone-300"></div></div>
                                        <div className="relative flex justify-center text-sm"><span className="px-2 bg-white text-stone-500">Or Join Existing</span></div>
                                    </div>

                                    <div className="flex gap-2">
                                        <input 
                                        type="text" 
                                        className="flex-1 p-2 border border-stone-300 rounded-md"
                                        placeholder="Enter Host ID"
                                        value={hostIdInput}
                                        onChange={(e) => setHostIdInput(e.target.value)}
                                        />
                                        <button 
                                        onClick={joinGame}
                                        disabled={!playerName || !selectedColor || !hostIdInput}
                                        className="px-6 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50"
                                        >
                                        Join
                                        </button>
                                    </div>
                                </>
                            )}
                            {joinError && <p className="text-red-500 text-sm text-center">{joinError}</p>}
                            </div>
                        </div>
                        </div>
                    </div>
                );
            }

            if (mode === 'LOBBY') {
                return (
                    <div className="min-h-screen bg-stone-100 flex items-center justify-center p-4">
                        <div className="max-w-2xl w-full bg-white rounded-xl shadow-xl p-8">
                        <h2 className="text-3xl font-bold text-stone-800 mb-6 text-center">Lobby</h2>
                        
                        {isHost && (
                            <div className="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200 flex flex-col items-center gap-2">
                            <span className="text-blue-800 font-medium">Share this Host ID with friends:</span>
                            <div className="flex items-center gap-2 bg-white px-4 py-2 rounded border border-blue-200">
                                <code className="text-lg font-mono font-bold">{myPeerId}</code>
                                <button onClick={() => navigator.clipboard.writeText(myPeerId)} className="text-blue-500 hover:text-blue-700"><Copy size={18}/></button>
                            </div>
                            </div>
                        )}

                        <div className="mb-8">
                            <h3 className="text-lg font-semibold mb-3 flex items-center gap-2"><Users size={20}/> Players ({renderedGameState.players.length}/4)</h3>
                            <div className="grid grid-cols-2 gap-4">
                            {renderedGameState.players.map(p => (
                                <div key={p.id} className="flex items-center gap-3 p-3 bg-stone-50 rounded-lg border border-stone-200">
                                <div className="w-8 h-8 rounded-full border-2 border-white shadow-sm" style={{ backgroundColor: p.color }}></div>
                                <span className="font-medium">{p.name} {p.isHost && '(Host)'} {p.id === myPeerId && '(You)'}</span>
                                </div>
                            ))}
                            {[...Array(4 - renderedGameState.players.length)].map((_, i) => (
                                <div key={i} className="flex items-center gap-3 p-3 bg-stone-50 rounded-lg border border-stone-200 border-dashed opacity-50">
                                <div className="w-8 h-8 rounded-full bg-stone-200"></div>
                                <span className="italic">Waiting...</span>
                                </div>
                            ))}
                            </div>
                        </div>

                        {isHost ? (
                            <button 
                            onClick={startGame}
                            className="w-full py-4 bg-green-600 text-white rounded-xl font-bold text-xl hover:bg-green-700 shadow-lg hover:shadow-green-200 transition-all"
                            >
                            Start Game
                            </button>
                        ) : (
                            <div className="text-center py-4 text-stone-500 animate-pulse">
                            Waiting for host to start the game...
                            </div>
                        )}
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-stone-900 p-4">
                    <div className="mb-4 flex items-center gap-6 text-white">
                        <div className="flex items-center gap-2">
                            <div className="p-2 bg-white/10 rounded-lg"><User size={20}/></div>
                            <span className="font-bold">{playerName}</span>
                        </div>
                        <div className="h-8 w-px bg-white/20"></div>
                        <div className="flex items-center gap-2">
                            <div className="p-2 bg-white/10 rounded-lg"><Info size={20}/></div>
                            <span>Controls: <b>WASD/Arrows</b> to Move, <b>SPACE</b> to Grab/Drop</span>
                        </div>
                    </div>
                    
                    <div className="relative">
                        <GameCanvas gameState={renderedGameState} myPeerId={myPeerId} />
                        
                        {renderedGameState.gameStatus === 'GAME_OVER' && (
                            <div className="absolute inset-0 flex items-center justify-end flex-col pb-24 pointer-events-none">
                                <div className="pointer-events-auto animate-bounce">
                                    {isHost ? (
                                        <button 
                                            onClick={restartGame}
                                            className="flex items-center gap-2 px-8 py-4 bg-green-600 hover:bg-green-700 text-white text-xl font-bold rounded-full shadow-xl transition-transform hover:scale-105"
                                        >
                                            <RotateCcw size={24} /> Play Again
                                        </button>
                                    ) : (
                                        <div className="px-6 py-3 bg-black/60 text-white rounded-full backdrop-blur-sm font-medium flex items-center gap-2">
                                            <Loader2 className="animate-spin" size={18} /> Waiting for Host to Restart...
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>