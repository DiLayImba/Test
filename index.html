
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Police Escape Co-op</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS (Global) & Babel -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1c1917; /* stone-900 */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: none;
        user-select: none;
      }
      canvas {
        touch-action: none;
        display: block;
      }
      /* Custom Scrollbar for chat/logs if needed */
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
      
      .scanline {
        background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
        background-size: 100% 4px;
        pointer-events: none;
      }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.344.0"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { User, Copy, Zap, Ghost, Snowflake, Shield, Bug, HeartPulse, Loader2, RotateCcw, Link as LinkIcon, Users, Hand } from 'lucide-react';

        // Access global PeerJS
        const Peer = window.Peer;

        // --- CONSTANTS & CONFIG ---
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const PLAYER_RADIUS = 15;
        const POLICE_RADIUS = 16;
        const PLAYER_SPEED = 4.8;
        const WALL_SIZE = 60;
        const WEB_RADIUS = 50;

        const POLICE_SPAWN_RATE = 5000;
        const POLICE_BASE_SPEED_RATIO = 0.4;
        const POLICE_MAX_SPEED_RATIO = 0.85;
        const POLICE_SPEED_GROWTH_INTERVAL = 5000;
        const ARREST_DURATION = 5000;
        const ATTACK_RADIUS = 70;
        const ATTACK_COOLDOWN = 500;
        const STUN_DURATION = 5000;
        const DASH_DISTANCE = PLAYER_RADIUS * 2 * 5;

        // Net Gunner Config
        const GUNNER_SPAWN_CHANCE = 0.3; // 20% chance to spawn WITH a normal cop
        const NET_COOLDOWN = 12000;
        const NET_PROJECTILE_SPEED = PLAYER_SPEED * 2.0;
        const NET_STUN_DURATION = 2000;
        const NET_PROJECTILE_RADIUS = 6;
        const GUNNER_SHOOT_RANGE = 180; // 6 * Player Diameter (roughly 30*4)

        const PlayerColor = {
            GREEN: '#22c55e',
            PINK: '#ec4899',
            PURPLE: '#a855f7',
            BLACK: '#171717',
        };

        const ABILITIES_DATA = {
            DASH: { name: 'Dash', desc: 'Dash forward instantly.', cd: 6000, icon: Zap },
            INVISIBILITY: { name: 'Stealth', desc: 'Invisible to police for 5s.', cd: 25000, icon: Ghost },
            FREEZE: { name: 'Freeze', desc: 'Stun all police for 2.5s.', cd: 30000, icon: Snowflake },
            WALL: { name: 'Barricade', desc: 'Drop a solid wall behind you.', cd: 20000, icon: Shield },
            WEB: { name: 'Spider Web', desc: 'Drop a slowing web.', cd: 10000, icon: Bug },
            SPEED: { name: 'Adrenaline', desc: 'Double speed for 4s.', cd: 24000, icon: HeartPulse },
            SECOND_LIFE: { name: 'Second Chance', desc: 'Respawn once automatically.', cd: 0, passive: true, icon: RotateCcw },
            SHOCKER: { name: 'Shocker', desc: 'Break free from arrest instantly.', cd: 30000, icon: Zap },
        };

        const INITIAL_GAME_STATE = {
            players: [],
            police: [],
            projectiles: [],
            walls: [],
            webs: [],
            gameStatus: 'LOBBY', // LOBBY, ABILITY_SELECTION, COUNTDOWN, PLAYING, GAME_OVER
            startTime: 0,
            survivalTime: 0,
            lastSpawnTime: 0,
            nextSpawnSide: 0,
            countdownValue: 3
        };

        // --- UTILS ---
        const distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

        const rectCircleColliding = (circle, rect) => {
            const distX = Math.abs(circle.x - rect.x - rect.w / 2);
            const distY = Math.abs(circle.y - rect.y - rect.h / 2);
            if (distX > (rect.w / 2 + circle.r)) return false;
            if (distY > (rect.h / 2 + circle.r)) return false;
            if (distX <= (rect.w / 2)) return true;
            if (distY <= (rect.h / 2)) return true;
            const dx = distX - rect.w / 2;
            const dy = distY - rect.h / 2;
            return (dx * dx + dy * dy <= (circle.r * circle.r));
        };

        // Returns the vector to push circle OUT of rect if overlapping
        const getPenetrationVector = (entity, rect, radius) => {
            const rectCenterX = rect.x + rect.w / 2;
            const rectCenterY = rect.y + rect.h / 2;
            
            const dx = entity.x - rectCenterX;
            const dy = entity.y - rectCenterY;
            
            const combinedHalfW = (rect.w / 2) + radius;
            const combinedHalfH = (rect.h / 2) + radius;
            
            if (Math.abs(dx) < combinedHalfW && Math.abs(dy) < combinedHalfH) {
                const overlapX = combinedHalfW - Math.abs(dx);
                const overlapY = combinedHalfH - Math.abs(dy);
                
                if (overlapX < overlapY) {
                    return { x: dx > 0 ? overlapX : -overlapX, y: 0 };
                } else {
                    return { x: 0, y: dy > 0 ? overlapY : -overlapY };
                }
            }
            return { x: 0, y: 0 };
        };

        const getSafeSpawn = (existingPlayers) => {
            const marginX = CANVAS_WIDTH * 0.15;
            const marginY = CANVAS_HEIGHT * 0.15;
            const safeWidth = CANVAS_WIDTH - (marginX * 2);
            const safeHeight = CANVAS_HEIGHT - (marginY * 2);
            
            let attempts = 0;
            let pos = { x: 0, y: 0 };
            let safe = false;

            while (!safe && attempts < 50) {
                pos.x = marginX + Math.random() * safeWidth;
                pos.y = marginY + Math.random() * safeHeight;
                safe = true;
                for (const p of existingPlayers) {
                    if (distance(pos.x, pos.y, p.x, p.y) < (PLAYER_RADIUS * 4)) {
                        safe = false;
                        break;
                    }
                }
                attempts++;
            }
            return pos;
        };

        // --- PHYSICS ENGINE ---
        const updatePhysics = (gameState, inputs) => {
            const newState = { ...gameState };
            const now = Date.now();

            if (newState.gameStatus === 'ABILITY_SELECTION') return newState;

            if (newState.gameStatus === 'COUNTDOWN') {
                const diff = now - newState.startTime;
                if (diff < 1000) newState.countdownValue = 3;
                else if (diff < 2000) newState.countdownValue = 2;
                else if (diff < 3000) newState.countdownValue = 1;
                else {
                    newState.gameStatus = 'PLAYING';
                    newState.startTime = now;
                    newState.lastSpawnTime = now;
                }
                return newState;
            }

            if (newState.gameStatus !== 'PLAYING') return newState;

            // 1. Update Players
            newState.players = newState.players.map(player => {
                if (player.isEliminated) return player;

                // Immobilized Check
                if (player.immobilizedUntil && now < player.immobilizedUntil) {
                     // Can't move or use abilities
                     return player;
                }

                const input = inputs[player.peerId];
                if (!input) return player;

                // Captured / Shocker
                if (player.isCaptured) {
                    if (player.selectedAbility === 'SHOCKER' && input.ability && (!player.abilityCooldown || now > player.abilityCooldown)) {
                        player.abilityCooldown = now + ABILITIES_DATA.SHOCKER.cd;
                        player.isCaptured = false;
                        const cop = newState.police.find(p => p.id === player.capturedBy);
                        if (cop) {
                            cop.state = 'STUNNED';
                            cop.stunUntil = now + STUN_DURATION;
                            cop.draggingPlayerId = null;
                        }
                        player.capturedBy = null;
                    }
                    return player;
                }

                // Movement
                let currentSpeed = PLAYER_SPEED;
                const inWeb = newState.webs.some(w => distance(player.x, player.y, w.x, w.y) < WEB_RADIUS);
                if (inWeb) currentSpeed *= 0.2;
                if (player.speedBoostUntil && now < player.speedBoostUntil) currentSpeed *= 1.8;

                let dx = 0;
                let dy = 0;
                if (input.up) dy -= currentSpeed;
                if (input.down) dy += currentSpeed;
                if (input.left) dx -= currentSpeed;
                if (input.right) dx += currentSpeed;

                if (dx !== 0 && dy !== 0) {
                    dx *= 0.7071;
                    dy *= 0.7071;
                }

                // Update Facing Direction for Abilities
                let dirX = player.dirX;
                let dirY = player.dirY;
                if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    dirX = dx / mag;
                    dirY = dy / mag;
                }

                // Abilities
                if (input.ability && player.selectedAbility && (!player.abilityCooldown || now > player.abilityCooldown)) {
                    const ab = ABILITIES_DATA[player.selectedAbility];
                    let activated = false;

                    if (player.selectedAbility === 'DASH') {
                        let dashX = player.x + dirX * DASH_DISTANCE;
                        let dashY = player.y + dirY * DASH_DISTANCE;
                        dashX = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, dashX));
                        dashY = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, dashY));
                        
                        // Prevent dashing INSIDE walls, but allow dashing NEAR them
                        let hitWall = false;
                        for (const w of newState.walls) {
                            if (rectCircleColliding({x: dashX, y: dashY, r: PLAYER_RADIUS}, w)) {
                                hitWall = true;
                                break;
                            }
                        }
                        if(!hitWall) {
                            player.x = dashX; 
                            player.y = dashY;
                            activated = true;
                        }
                    }
                    else if (player.selectedAbility === 'INVISIBILITY') {
                        player.invisibleUntil = now + 5000;
                        activated = true;
                    }
                    else if (player.selectedAbility === 'FREEZE') {
                        newState.police.forEach(p => { p.state = 'STUNNED'; p.stunUntil = now + 2500; });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'WALL') {
                        // Place wall slightly behind player
                        newState.walls.push({
                            id: `wall-${now}-${player.peerId}`,
                            x: player.x - (dirX * 40) - (WALL_SIZE/2),
                            y: player.y - (dirY * 40) - (WALL_SIZE/2),
                            w: WALL_SIZE,
                            h: WALL_SIZE
                        });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'WEB') {
                        newState.webs.push({
                            id: `web-${now}-${player.peerId}`,
                            x: player.x - (dirX * 20),
                            y: player.y - (dirY * 20)
                        });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'SPEED') {
                        player.speedBoostUntil = now + 4000;
                        activated = true;
                    }

                    if (activated) player.abilityCooldown = now + ab.cd;
                }

                let newX = player.x + dx;
                let newY = player.y + dy;

                // Wall Collision (With Ejection)
                for (const w of newState.walls) {
                    // Check if we were ALREADY inside (e.g. wall spawned on us)
                    const wasInside = rectCircleColliding({x: player.x, y: player.y, r: PLAYER_RADIUS}, w);
                    
                    if (wasInside) {
                         // Push out logic
                         const push = getPenetrationVector({x: newX, y: newY}, w, PLAYER_RADIUS);
                         newX += push.x;
                         newY += push.y;
                    } else {
                        // Standard collision stopping
                        if (rectCircleColliding({x: newX, y: player.y, r: PLAYER_RADIUS}, w)) newX = player.x;
                        if (rectCircleColliding({x: player.x, y: newY, r: PLAYER_RADIUS}, w)) newY = player.y;
                    }
                }

                newX = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, newX));
                newY = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, newY));

                // Combat / Rescue
                if (input.action && now - player.lastAttack > ATTACK_COOLDOWN) {
                    player.lastAttack = now;
                    // Stun police nearby (ONLY IF DRAGGING A PLAYER)
                    newState.police.forEach(cop => {
                        if (distance(newX, newY, cop.x, cop.y) < ATTACK_RADIUS) {
                            if (cop.draggingPlayerId) {
                                cop.state = 'STUNNED';
                                cop.stunUntil = now + STUN_DURATION;
                                // Drop victim if carrying
                                const victim = newState.players.find(p => p.peerId === cop.draggingPlayerId);
                                if (victim) {
                                    victim.isCaptured = false;
                                    victim.capturedBy = null;
                                    // Grant Invulnerability for 2s
                                    victim.invulnerableUntil = now + 2000;
                                }
                                cop.draggingPlayerId = null;
                            }
                        }
                    });
                }

                return { ...player, x: newX, y: newY, dirX, dirY };
            });

            // 2. Player-Player Collision (Soft Push)
            for(let i=0; i < newState.players.length; i++) {
                for(let j=i+1; j < newState.players.length; j++) {
                    const p1 = newState.players[i];
                    const p2 = newState.players[j];
                    if (p1.isEliminated || p2.isEliminated) continue;
                    
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = PLAYER_RADIUS * 2;
                    
                    if (dist < minDist && dist > 0) {
                        const overlap = (minDist - dist) / 2;
                        const offX = (dx / dist) * overlap;
                        const offY = (dy / dist) * overlap;
                        p1.x += offX; p1.y += offY;
                        p2.x -= offX; p2.y -= offY;
                    }
                }
            }

            // 3. Projectiles (Nets) Logic
            newState.projectiles = newState.projectiles.filter(proj => {
                // Move
                proj.x += proj.vx;
                proj.y += proj.vy;

                // Check bounds
                if (proj.x < -50 || proj.x > CANVAS_WIDTH + 50 || proj.y < -50 || proj.y > CANVAS_HEIGHT + 50) {
                    return false;
                }

                // Check Collision with Players
                let hit = false;
                newState.players.forEach(p => {
                    if (!p.isEliminated && !p.isCaptured && !hit) {
                         // Don't hit invulnerable or invisible or already immobilized
                         const isInvuln = p.invulnerableUntil && now < p.invulnerableUntil;
                         if (isInvuln) return;

                         if (distance(proj.x, proj.y, p.x, p.y) < (PLAYER_RADIUS + NET_PROJECTILE_RADIUS)) {
                             p.immobilizedUntil = now + NET_STUN_DURATION;
                             hit = true;
                         }
                    }
                });

                return !hit; // Remove if hit
            });


            // 4. Spawn Police
            if (now - newState.lastSpawnTime > POLICE_SPAWN_RATE && newState.players.some(p => !p.isEliminated)) {
                newState.lastSpawnTime = now;
                const edge = newState.nextSpawnSide;
                
                // Helper to get spawn coord
                const getSpawnCoord = (e) => {
                     if (e === 0) return { x: Math.random() * CANVAS_WIDTH, y: -30 };
                     else if (e === 1) return { x: CANVAS_WIDTH + 30, y: Math.random() * CANVAS_HEIGHT };
                     else if (e === 2) return { x: Math.random() * CANVAS_WIDTH, y: CANVAS_HEIGHT + 30 };
                     else return { x: -30, y: Math.random() * CANVAS_HEIGHT };
                };

                const pos = getSpawnCoord(edge);
                newState.police.push({
                    id: `police-${now}`,
                    type: 'NORMAL',
                    x: pos.x, y: pos.y,
                    state: 'CHASING',
                    stunUntil: 0, arrestStartTime: 0, draggingPlayerId: null
                });

                // 20% Chance to Spawn Gunner WITH Normal cop
                if (Math.random() < GUNNER_SPAWN_CHANCE) {
                     const gunnerPos = getSpawnCoord(edge); // Same side
                     newState.police.push({
                        id: `police-gunner-${now}`,
                        type: 'GUNNER',
                        x: gunnerPos.x, y: gunnerPos.y,
                        state: 'CHASING',
                        stunUntil: 0, arrestStartTime: 0, draggingPlayerId: null,
                        lastShot: 0, // Start READY (0 means it can shoot immediately)
                        cooldownOffset: Math.random() * 3000 // Add up to 3s random variance to cooldowns
                    });
                }

                newState.nextSpawnSide = Math.floor(Math.random() * 4);
            }

            // 5. Update Police
            const activePlayers = newState.players.filter(p => !p.isEliminated && !p.isCaptured);
            const visiblePlayers = activePlayers.filter(p => !p.invisibleUntil || now > p.invisibleUntil);
            
            const timePlayed = newState.survivalTime * 1000;
            const speedStage = Math.min(10, Math.floor(timePlayed / POLICE_SPEED_GROWTH_INTERVAL));
            const currentPoliceSpeedFactor = POLICE_BASE_SPEED_RATIO + (speedStage * 0.04);
            const basePoliceSpeed = Math.min(PLAYER_SPEED * POLICE_MAX_SPEED_RATIO, PLAYER_SPEED * currentPoliceSpeedFactor);

            newState.police = newState.police.map(cop => {
                if (cop.state === 'STUNNED') {
                    if (now > cop.stunUntil) cop.state = 'CHASING';
                    return cop;
                }

                let speed = basePoliceSpeed;
                if (newState.webs.some(w => distance(cop.x, cop.y, w.x, w.y) < WEB_RADIUS)) speed *= 0.2;

                // Gunner Shooting Logic
                if (cop.type === 'GUNNER' && cop.state === 'CHASING') {
                    const effectiveCooldown = NET_COOLDOWN + (cop.cooldownOffset || 0);
                    
                    if (now - cop.lastShot > effectiveCooldown) {
                        // Find nearest target
                        let nearest = null;
                        let minD = Infinity;
                        visiblePlayers.forEach(p => {
                            // Don't shoot invulnerable players
                            if (p.invulnerableUntil && now < p.invulnerableUntil) return;
                            
                            const d = distance(cop.x, cop.y, p.x, p.y);
                            if (d < minD) { minD = d; nearest = p; }
                        });

                        // Only shoot if in range
                        if (nearest && minD <= GUNNER_SHOOT_RANGE) {
                            // Shoot
                            cop.lastShot = now;
                            const ang = Math.atan2(nearest.y - cop.y, nearest.x - cop.x);
                            newState.projectiles.push({
                                x: cop.x,
                                y: cop.y,
                                vx: Math.cos(ang) * NET_PROJECTILE_SPEED,
                                vy: Math.sin(ang) * NET_PROJECTILE_SPEED
                            });
                        }
                    }
                }

                let vx = 0, vy = 0;

                // State Machine
                if (cop.state === 'EXITING') {
                    // Head to center edge or specific exit? Just run away from center
                    const centerX = CANVAS_WIDTH/2;
                    const centerY = CANVAS_HEIGHT/2;
                    const angle = Math.atan2(cop.y - centerY, cop.x - centerX);
                    vx = Math.cos(angle) * speed * 1.5;
                    vy = Math.sin(angle) * speed * 1.5;
                }
                else if (cop.state === 'ARRESTING') {
                    if (now - cop.arrestStartTime > ARREST_DURATION) cop.state = 'DRAGGING';
                    // Keep victim pinned
                    if (cop.draggingPlayerId) {
                        const vIdx = newState.players.findIndex(p => p.peerId === cop.draggingPlayerId);
                        if (vIdx !== -1) { newState.players[vIdx].x = cop.x; newState.players[vIdx].y = cop.y; }
                    }
                    return cop; // No movement during arrest animation
                }
                else if (cop.state === 'DRAGGING') {
                    // Drag to nearest edge with OBSTACLE AVOIDANCE
                    const distTop = cop.y;
                    const distBottom = CANVAS_HEIGHT - cop.y;
                    const distLeft = cop.x;
                    const distRight = CANVAS_WIDTH - cop.x;
                    const minDist = Math.min(distTop, distBottom, distLeft, distRight);
                    speed *= 0.6; // Slower when dragging

                    // 1. Determine Goal Velocity
                    let targetVx = 0;
                    let targetVy = 0;

                    if (minDist === distTop) targetVy = -speed;
                    else if (minDist === distBottom) targetVy = speed;
                    else if (minDist === distLeft) targetVx = -speed;
                    else targetVx = speed;

                    // 2. Obstacle Avoidance Lookahead
                    const lookAheadDist = POLICE_RADIUS + 15; 
                    let blocked = false;
                    let wallCenter = { x: 0, y: 0 };

                    for (const w of newState.walls) {
                        const testCircle = {
                            x: cop.x + (targetVx !== 0 ? Math.sign(targetVx) * lookAheadDist : 0),
                            y: cop.y + (targetVy !== 0 ? Math.sign(targetVy) * lookAheadDist : 0),
                            r: POLICE_RADIUS
                        };
                        
                        if (rectCircleColliding(testCircle, w)) {
                            blocked = true;
                            wallCenter = { x: w.x + w.w/2, y: w.y + w.h/2 };
                            break;
                        }
                    }

                    if (blocked) {
                        // If blocked Vertical, go Horizontal
                        if (targetVy !== 0) {
                            targetVy = 0;
                            // Move towards side closer to cop to clear wall
                            targetVx = (cop.x < wallCenter.x) ? -speed : speed;
                        }
                        // If blocked Horizontal, go Vertical
                        else if (targetVx !== 0) {
                            targetVx = 0;
                            targetVy = (cop.y < wallCenter.y) ? -speed : speed;
                        }
                    }

                    vx = targetVx;
                    vy = targetVy;

                    if (cop.draggingPlayerId) {
                        const vIdx = newState.players.findIndex(p => p.peerId === cop.draggingPlayerId);
                        if (vIdx !== -1) {
                            const victim = newState.players[vIdx];
                            victim.x = cop.x; victim.y = cop.y;
                            
                            // Check if exited
                            if (cop.x < -20 || cop.x > CANVAS_WIDTH+20 || cop.y < -20 || cop.y > CANVAS_HEIGHT+20) {
                                if (victim.selectedAbility === 'SECOND_LIFE' && !victim.secondLifeUsed) {
                                    // Respawn
                                    victim.secondLifeUsed = true;
                                    victim.isCaptured = false;
                                    victim.capturedBy = null;
                                    const pos = getSafeSpawn(newState.players);
                                    victim.x = pos.x; victim.y = pos.y;
                                    cop.state = 'EXITING';
                                    cop.draggingPlayerId = null;
                                } else {
                                    // Eliminated
                                    victim.isEliminated = true;
                                    victim.isCaptured = false;
                                    cop.state = 'EXITING';
                                    cop.draggingPlayerId = null;
                                }
                            }
                        } else cop.state = 'CHASING';
                    } else cop.state = 'CHASING';
                }
                else if (cop.state === 'CHASING') {
                    let nearest = null;
                    let minD = Infinity;
                    visiblePlayers.forEach(p => {
                        // Check Invulnerability
                        if (p.invulnerableUntil && now < p.invulnerableUntil) return;

                        const d = distance(cop.x, cop.y, p.x, p.y);
                        if (d < minD) { minD = d; nearest = p; }
                    });

                    if (nearest) {
                        const angle = Math.atan2(nearest.y - cop.y, nearest.x - cop.x);
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;
                        
                        if (distance(cop.x, cop.y, nearest.x, nearest.y) < (POLICE_RADIUS + PLAYER_RADIUS)) {
                            cop.state = 'ARRESTING';
                            cop.arrestStartTime = now;
                            cop.draggingPlayerId = nearest.peerId;
                            const pIdx = newState.players.findIndex(p => p.peerId === nearest.peerId);
                            if (pIdx !== -1) {
                                newState.players[pIdx].isCaptured = true;
                                newState.players[pIdx].capturedBy = cop.id;
                                newState.players[pIdx].x = cop.x;
                                newState.players[pIdx].y = cop.y;
                            }
                            vx=0; vy=0;
                        }
                    } else {
                        // Wander to center
                        const angle = Math.atan2(CANVAS_HEIGHT/2 - cop.y, CANVAS_WIDTH/2 - cop.x);
                        vx = Math.cos(angle) * (speed*0.5);
                        vy = Math.sin(angle) * (speed*0.5);
                    }
                }

                let nextX = cop.x + vx;
                let nextY = cop.y + vy;

                // Police Wall Collision (With Ejection)
                for (const w of newState.walls) {
                    const wasInside = rectCircleColliding({x: cop.x, y: cop.y, r: POLICE_RADIUS}, w);
                    
                    if (wasInside) {
                         // Push out
                         const push = getPenetrationVector({x: nextX, y: nextY}, w, POLICE_RADIUS);
                         nextX += push.x;
                         nextY += push.y;
                    } else {
                        if (rectCircleColliding({x: nextX, y: cop.y, r: POLICE_RADIUS}, w)) nextX = cop.x;
                        if (rectCircleColliding({x: cop.x, y: nextY, r: POLICE_RADIUS}, w)) nextY = cop.y;
                    }
                }

                return { ...cop, x: nextX, y: nextY };
            });

            // 6. Police Separation (Prevent stacking)
            for(let iter=0; iter<2; iter++) {
                for (let i = 0; i < newState.police.length; i++) {
                    for (let j = i + 1; j < newState.police.length; j++) {
                        const p1 = newState.police[i];
                        const p2 = newState.police[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < POLICE_RADIUS * 2 && dist > 0) {
                            const overlap = (POLICE_RADIUS*2 - dist)/2;
                            const ox = (dx/dist)*overlap; const oy = (dy/dist)*overlap;
                            p1.x+=ox; p1.y+=oy; p2.x-=ox; p2.y-=oy;
                        }
                    }
                }
            }

            // Cleanup
            newState.police = newState.police.filter(cop => {
                if (cop.state === 'EXITING') return (cop.x > -100 && cop.x < CANVAS_WIDTH+100 && cop.y > -100 && cop.y < CANVAS_HEIGHT+100);
                return true;
            });

            const aliveCount = newState.players.filter(p => !p.isEliminated).length;
            if (newState.players.length > 0 && aliveCount === 0) newState.gameStatus = 'GAME_OVER';
            else newState.survivalTime = (now - newState.startTime) / 1000;

            return newState;
        };

        // --- COMPONENTS ---

        const AbilityCard = ({ id, data, selected, onSelect }) => {
             const Icon = data.icon || Zap;
             return (
                <div 
                    onClick={() => onSelect(id)}
                    className={`p-4 border-2 rounded-lg cursor-pointer transition-all flex flex-col items-center text-center h-full ${
                        selected ? 'border-green-500 bg-green-500/20 scale-105 shadow-lg shadow-green-500/20' : 'border-stone-700 hover:border-stone-500 bg-stone-800/50'
                    }`}
                >
                    <Icon className={`w-8 h-8 mb-2 ${selected ? 'text-green-400' : 'text-stone-400'}`} />
                    <div className="flex items-center gap-2 mb-1">
                        <span className="font-bold text-stone-100">{data.name}</span>
                        {data.passive && <span className="text-[10px] bg-blue-500 text-white px-1 rounded font-mono uppercase">Passive</span>}
                    </div>
                    <p className="text-xs text-stone-400 leading-snug mb-2 flex-grow">{data.desc}</p>
                    <div className="mt-auto text-xs font-mono text-stone-500">CD: {data.cd/1000}s</div>
                </div>
            );
        };

        const App = () => {
            // State
            const [myPeerId, setMyPeerId] = useState(null);
            const [hostId, setHostId] = useState('');
            const [role, setRole] = useState(null); // 'HOST' | 'CLIENT'
            const [status, setStatus] = useState('LOBBY'); // LOBBY, ABILITY_SELECTION, PLAYING
            const [myName, setMyName] = useState('');
            const [myColor, setMyColor] = useState(PlayerColor.GREEN);
            const [playersList, setPlayersList] = useState([]); // For lobby UI
            const [offeredAbilities, setOfferedAbilities] = useState([]); // The 3 random abilities
            const [showRestart, setShowRestart] = useState(false); // Track game over restart button visibility
            
            // Game State Refs
            const gameStateRef = useRef(JSON.parse(JSON.stringify(INITIAL_GAME_STATE)));
            const inputsRef = useRef({});
            const myInputRef = useRef({ up: false, down: false, left: false, right: false, action: false, ability: false });
            
            // Networking Refs
            const peerRef = useRef(null);
            const connsRef = useRef([]); // For Host: array of connections
            const connRef = useRef(null); // For Client: connection to host
            
            // Canvas
            const canvasRef = useRef(null);
            const requestRef = useRef(null);

            // Initialize Peer
            useEffect(() => {
                const peer = new Peer();
                peer.on('open', (id) => {
                    setMyPeerId(id);
                    console.log('My Peer ID:', id);
                });

                peer.on('connection', (conn) => {
                    // Host receives connection
                    conn.on('open', () => {
                        console.log('Incoming connection from', conn.peer);
                        connsRef.current.push(conn);

                        // Setup data listener for this client
                        conn.on('data', (data) => {
                            if (data.type === 'JOIN') {
                                setPlayersList(prev => {
                                    if (prev.find(p => p.id === conn.peer)) return prev;
                                    return [...prev, { id: conn.peer, name: data.name, color: data.color }];
                                });
                            }
                            else if (data.type === 'INPUT') {
                                inputsRef.current[conn.peer] = data.input;
                            }
                            else if (data.type === 'ABILITY_SELECT') {
                                const p = gameStateRef.current.players.find(p => p.peerId === conn.peer);
                                if (p) p.selectedAbility = data.ability;
                            }
                        });

                        // Send current state immediately?
                        conn.send({ type: 'LOBBY_UPDATE', players: playersList }); // Optimistic
                    });
                });

                peerRef.current = peer;
                return () => peer.destroy();
            }, []);

            // Sync Players List in Lobby (Host side logic mostly)
            useEffect(() => {
                if (role === 'HOST') {
                    const list = [{ id: myPeerId, name: myName, color: myColor }, ...playersList.filter(p => p.id !== myPeerId)];
                     // Broadcast
                    connsRef.current.forEach(c => {
                        if(c.open) c.send({ type: 'LOBBY_UPDATE', players: list });
                    });
                }
            }, [playersList, role, myName, myColor, myPeerId]);

            // Monitor Game Status to Switch UI (CRITICAL FIX)
            useEffect(() => {
                const interval = setInterval(() => {
                    const gs = gameStateRef.current.gameStatus;
                    
                    // Transition: Selection -> Playing
                    if (status === 'ABILITY_SELECTION' && (gs === 'COUNTDOWN' || gs === 'PLAYING')) {
                        setStatus('PLAYING');
                    }
                    
                    // Transition: Playing -> Selection (Restart)
                    if (status === 'PLAYING' && gs === 'ABILITY_SELECTION') {
                        setStatus('ABILITY_SELECTION');
                        setShowRestart(false);
                    }

                    // Transition: Playing -> Lobby (Full quit?)
                    if (status === 'PLAYING' && gs === 'LOBBY') {
                        setStatus('LOBBY');
                        setRole(null);
                        setShowRestart(false);
                    }
                    
                    // Sync Restart Button
                    if (role === 'HOST') {
                        const isGameOver = (gs === 'GAME_OVER');
                        if (isGameOver && !showRestart) setShowRestart(true);
                        if (!isGameOver && showRestart) setShowRestart(false);
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [status, role, showRestart]);

            // Game Loop
            const animate = useCallback(() => {
                if (role === 'HOST') {
                    // 1. Gather Inputs
                    if (myPeerId) inputsRef.current[myPeerId] = myInputRef.current;

                    // 2. Run Physics
                    gameStateRef.current = updatePhysics(gameStateRef.current, inputsRef.current);

                    // 3. Broadcast State
                    const stateSnapshot = gameStateRef.current;
                    connsRef.current.forEach(c => {
                        if (c.open) c.send({ type: 'GAME_UPDATE', state: stateSnapshot });
                    });
                }

                // 4. Render
                if (canvasRef.current) {
                    const ctx = canvasRef.current.getContext('2d');
                    renderGame(ctx, gameStateRef.current, myPeerId);
                }

                requestRef.current = requestAnimationFrame(animate);
            }, [role, myPeerId]);

            useEffect(() => {
                requestRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(requestRef.current);
            }, [animate]);

            // Input Listeners
            useEffect(() => {
                const handleKeyDown = (e) => {
                    const key = e.key.toLowerCase();
                    const code = e.code;
                    
                    if (key === 'w' || key === 'arrowup' || code === 'KeyW') myInputRef.current.up = true;
                    if (key === 's' || key === 'arrowdown' || code === 'KeyS') myInputRef.current.down = true;
                    if (key === 'a' || key === 'arrowleft' || code === 'KeyA') myInputRef.current.left = true;
                    if (key === 'd' || key === 'arrowright' || code === 'KeyD') myInputRef.current.right = true;
                    if (key === ' ' || key === 'x') myInputRef.current.action = true; // Attack/Rescue
                    if (key === 'e' || code === 'KeyE') myInputRef.current.ability = true; // Ability

                    // Send Input if Client
                    if (role === 'CLIENT' && connRef.current?.open) {
                        connRef.current.send({ type: 'INPUT', input: myInputRef.current });
                    }
                };
                const handleKeyUp = (e) => {
                    const key = e.key.toLowerCase();
                    const code = e.code;

                    if (key === 'w' || key === 'arrowup' || code === 'KeyW') myInputRef.current.up = false;
                    if (key === 's' || key === 'arrowdown' || code === 'KeyS') myInputRef.current.down = false;
                    if (key === 'a' || key === 'arrowleft' || code === 'KeyA') myInputRef.current.left = false;
                    if (key === 'd' || key === 'arrowright' || code === 'KeyD') myInputRef.current.right = false;
                    if (key === ' ' || key === 'x') myInputRef.current.action = false;
                    if (key === 'e' || code === 'KeyE') myInputRef.current.ability = false;

                    if (role === 'CLIENT' && connRef.current?.open) {
                        connRef.current.send({ type: 'INPUT', input: myInputRef.current });
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [role]);


            const startHosting = () => {
                if (!myName) return alert("Enter name first");
                setRole('HOST');
                setStatus('LOBBY');
                setHostId(myPeerId);
                setPlayersList([{ id: myPeerId, name: myName, color: myColor }]);
            };

            const joinGame = () => {
                if (!myName) return alert("Enter name first");
                if (!hostId) return alert("Enter Host ID");
                
                const conn = peerRef.current.connect(hostId);
                conn.on('open', () => {
                    setRole('CLIENT');
                    setStatus('LOBBY');
                    conn.send({ type: 'JOIN', name: myName, color: myColor });
                });
                conn.on('data', (data) => {
                    if (data.type === 'LOBBY_UPDATE') {
                        setPlayersList(data.players);
                    }
                    else if (data.type === 'GAME_START' || data.type === 'GAME_RESTART') {
                        setStatus('ABILITY_SELECTION');
                        // Select 3 randoms
                        const all = Object.keys(ABILITIES_DATA);
                        setOfferedAbilities(all.sort(() => 0.5 - Math.random()).slice(0, 3));
                        gameStateRef.current = data.initialState; // Reset state
                    }
                    else if (data.type === 'GAME_UPDATE') {
                        gameStateRef.current = data.state;
                    }
                });
                connRef.current = conn;
            };

            const startGame = () => {
                // Initialize Game State
                const initialPlayers = playersList.map((p, i) => ({
                    peerId: p.id,
                    name: p.name,
                    color: p.color,
                    x: CANVAS_WIDTH/2 + (i%2===0 ? 40 : -40),
                    y: CANVAS_HEIGHT/2 + (i>1 ? 40 : -40),
                    dirX: 1, dirY: 0,
                    selectedAbility: null,
                    abilityCooldown: 0,
                    isCaptured: false,
                    capturedBy: null,
                    isEliminated: false,
                    lastAttack: 0,
                    secondLifeUsed: false,
                    invulnerableUntil: 0, // Initialize
                    immobilizedUntil: 0 // Initialize
                }));

                const newState = {
                    ...INITIAL_GAME_STATE,
                    players: initialPlayers,
                    police: [], // Explicitly clear police
                    projectiles: [], // Explicitly clear projectiles
                    walls: [],  // Explicitly clear walls
                    webs: [],   // Explicitly clear webs
                    gameStatus: 'ABILITY_SELECTION'
                };

                gameStateRef.current = newState;
                setStatus('ABILITY_SELECTION');
                setShowRestart(false); // Ensure restart button gone
                
                // Select 3 randoms for Host
                const all = Object.keys(ABILITIES_DATA);
                setOfferedAbilities(all.sort(() => 0.5 - Math.random()).slice(0, 3));

                // Notify Clients
                connsRef.current.forEach(c => {
                    if (c.open) c.send({ type: 'GAME_START', initialState: newState });
                });
            };

            const restartGame = () => {
                 // Reuse existing players list, but reset their in-game state
                 startGame(); 
            }

            const selectAbility = (abilityKey) => {
                // Local update
                if (role === 'HOST') {
                    const p = gameStateRef.current.players.find(p => p.peerId === myPeerId);
                    if (p) p.selectedAbility = abilityKey;
                    
                    // Check if all ready
                    checkStartGame();
                } else {
                    connRef.current.send({ type: 'ABILITY_SELECT', ability: abilityKey });
                }
            };

            // Only Host runs this
            const checkStartGame = () => {
                const allReady = gameStateRef.current.players.every(p => p.selectedAbility);
                if (allReady) {
                    gameStateRef.current.gameStatus = 'COUNTDOWN';
                    gameStateRef.current.startTime = Date.now(); // Start countdown timestamp
                }
            };
            
            // Helper to render
            const renderGame = (ctx, state, myId) => {
                // BG
                ctx.fillStyle = '#1c1917';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Spawn Indicator (Pulsating)
                if (state.gameStatus === 'PLAYING') {
                    const side = state.nextSpawnSide;
                    const now = Date.now();
                    // Faster, brighter pulse: 0.4 to 0.8 opacity
                    const alpha = 0.4 + 0.4 * Math.sin(now / 200); 
                    const color = `rgba(239, 68, 68, ${alpha})`;
                    const transparent = `rgba(239, 68, 68, 0)`;
                    
                    ctx.save();
                    let gradient;
                    
                    // 0: Top, 1: Right, 2: Bottom, 3: Left
                    // Draw gradient from edge inwards
                    if (side === 0) {
                        gradient = ctx.createLinearGradient(0, 0, 0, 60);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, transparent);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, CANVAS_WIDTH, 60);
                    } else if (side === 1) {
                        gradient = ctx.createLinearGradient(CANVAS_WIDTH, 0, CANVAS_WIDTH - 60, 0);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, transparent);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(CANVAS_WIDTH - 60, 0, 60, CANVAS_HEIGHT);
                    } else if (side === 2) {
                        gradient = ctx.createLinearGradient(0, CANVAS_HEIGHT, 0, CANVAS_HEIGHT - 60);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, transparent);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, CANVAS_HEIGHT - 60, CANVAS_WIDTH, 60);
                    } else if (side === 3) {
                        gradient = ctx.createLinearGradient(0, 0, 60, 0);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, transparent);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 60, CANVAS_HEIGHT);
                    }
                    
                    ctx.restore();
                }

                // Grid
                ctx.strokeStyle = '#292524';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let x=0; x<=CANVAS_WIDTH; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x, CANVAS_HEIGHT); }
                for(let y=0; y<=CANVAS_HEIGHT; y+=100) { ctx.moveTo(0,y); ctx.lineTo(CANVAS_WIDTH, y); }
                ctx.stroke();

                // Walls
                ctx.fillStyle = '#57534e';
                ctx.strokeStyle = '#78716c';
                state.walls.forEach(w => {
                    ctx.fillRect(w.x, w.y, w.w, w.h);
                    ctx.strokeRect(w.x, w.y, w.w, w.h);
                    // 3D effect
                    ctx.fillStyle = '#44403c';
                    ctx.fillRect(w.x+5, w.y+w.h, w.w, 10);
                    ctx.fillStyle = '#57534e';
                });

                // Webs
                state.webs.forEach(w => {
                    ctx.beginPath();
                    ctx.arc(w.x, w.y, WEB_RADIUS, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.stroke();
                    // Cross
                    ctx.moveTo(w.x-WEB_RADIUS, w.y-WEB_RADIUS); ctx.lineTo(w.x+WEB_RADIUS, w.y+WEB_RADIUS);
                    ctx.moveTo(w.x+WEB_RADIUS, w.y-WEB_RADIUS); ctx.lineTo(w.x-WEB_RADIUS, w.y+WEB_RADIUS);
                    ctx.stroke();
                });

                // Projectiles (Nets)
                if (state.projectiles) {
                    state.projectiles.forEach(proj => {
                        ctx.beginPath();
                        ctx.arc(proj.x, proj.y, NET_PROJECTILE_RADIUS, 0, Math.PI*2);
                        ctx.fillStyle = '#a855f7'; // Purple projectile
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.stroke();
                    });
                }

                // Players
                state.players.forEach(p => {
                    if (p.isEliminated) return;

                    const isMe = p.peerId === myId;
                    const isInv = p.invisibleUntil && Date.now() < p.invisibleUntil;
                    const isInvuln = p.invulnerableUntil && Date.now() < p.invulnerableUntil;
                    const isImmobilized = p.immobilizedUntil && Date.now() < p.immobilizedUntil;
                    
                    // Opacity if invisible
                    ctx.globalAlpha = (isInv && !isMe) ? 0 : (isInv && isMe ? 0.5 : 1);

                    // Invulnerability Shield
                    if (isInvuln) {
                         ctx.save();
                         ctx.strokeStyle = '#fbbf24'; // Amber-400
                         ctx.lineWidth = 3;
                         ctx.beginPath();
                         ctx.arc(p.x, p.y, PLAYER_RADIUS + 5, 0, Math.PI*2);
                         ctx.stroke();
                         ctx.restore();
                    }

                    // Immobilized Net Effect
                    if (isImmobilized) {
                        ctx.save();
                        ctx.strokeStyle = '#a855f7'; // Purple net
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, PLAYER_RADIUS + 3, 0, Math.PI*2);
                        ctx.stroke();
                        // Grid pattern on player
                        ctx.beginPath();
                        ctx.moveTo(p.x - 10, p.y - 10); ctx.lineTo(p.x + 10, p.y + 10);
                        ctx.moveTo(p.x + 10, p.y - 10); ctx.lineTo(p.x - 10, p.y + 10);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Body
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = isMe ? '#fff' : '#000';
                    ctx.stroke();
                    
                    // Attack Animation (Visual)
                    if (Date.now() - p.lastAttack < 150) {
                        ctx.beginPath();
                        const ang = Math.atan2(p.dirY, p.dirX);
                        ctx.arc(p.x, p.y, ATTACK_RADIUS, ang - 0.8, ang + 0.8);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // Name
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.name, p.x, p.y - 25);

                    // Status
                    if (p.isCaptured) {
                         ctx.fillStyle = '#ef4444';
                         ctx.fillText("ARRESTED", p.x, p.y - 40);
                    }
                    if (isImmobilized) {
                         ctx.fillStyle = '#a855f7';
                         ctx.fillText("NET!", p.x, p.y - 40);
                    }
                    
                    ctx.globalAlpha = 1;
                });

                // Police
                state.police.forEach(cop => {
                    ctx.beginPath();
                    ctx.arc(cop.x, cop.y, POLICE_RADIUS, 0, Math.PI * 2);
                    
                    // Color based on type
                    if (cop.type === 'GUNNER') ctx.fillStyle = '#7c3aed'; // Dark purple for Gunner
                    else ctx.fillStyle = '#3b82f6'; // Blue for Normal
                    
                    if (cop.state === 'STUNNED') ctx.fillStyle = '#facc15'; // Yellow when stunned
                    if (cop.state === 'ARRESTING') ctx.fillStyle = '#ef4444'; // Red when arresting
                    
                    ctx.fill();
                    ctx.strokeStyle = '#1e3a8a';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Hat (Visual)
                    ctx.fillStyle = '#1e3a8a';
                    ctx.fillRect(cop.x-10, cop.y-POLICE_RADIUS-5, 20, 10);
                    
                    // Gunner visual distinctive mark
                    if (cop.type === 'GUNNER') {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(cop.x + 12, cop.y - 2, 10, 4); // Gun barrel sticking out right (simplified)
                    }

                    // Status Text
                    if (cop.state === 'STUNNED') {
                        ctx.fillStyle = '#facc15';
                        ctx.font = '10px Arial';
                        ctx.fillText("STUNNED", cop.x, cop.y - 25);
                    }
                });
                
                // HUD
                if (state.gameStatus === 'PLAYING' || state.gameStatus === 'COUNTDOWN') {
                    ctx.fillStyle = '#fff';
                    ctx.font = '24px monospace';
                    ctx.textAlign = 'left';
                    const minutes = Math.floor(state.survivalTime / 60);
                    const seconds = Math.floor(state.survivalTime % 60);
                    ctx.fillText(`TIME: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 40);

                    // Alive count
                    const alive = state.players.filter(p => !p.isEliminated).length;
                    ctx.textAlign = 'right';
                    ctx.fillText(`ALIVE: ${alive}/${state.players.length}`, CANVAS_WIDTH - 20, 40);

                    // Cooldown (My HUD)
                    if (myId) {
                        const me = state.players.find(p => p.peerId === myId);
                        if (me && me.selectedAbility) {
                            const ab = ABILITIES_DATA[me.selectedAbility];
                            const cdTime = Math.max(0, (me.abilityCooldown - Date.now())/1000).toFixed(1);
                            
                            ctx.textAlign = 'center';
                            ctx.fillStyle = cdTime > 0 ? '#ef4444' : '#22c55e';
                            ctx.font = '16px sans-serif';
                            ctx.fillText(`${ab.name}: ${cdTime > 0 ? cdTime + 's' : 'READY'}`, CANVAS_WIDTH/2, CANVAS_HEIGHT - 20);
                            
                            if (me.immobilizedUntil && Date.now() < me.immobilizedUntil) {
                                ctx.fillStyle = '#a855f7';
                                ctx.fillText("IMMOBILIZED!", CANVAS_WIDTH/2, CANVAS_HEIGHT - 50);
                            }
                        }
                    }
                }
                
                if (state.gameStatus === 'COUNTDOWN') {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.fillStyle = '#fff';
                    ctx.font = '120px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(state.countdownValue, CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
                    ctx.textBaseline = 'alphabetic';
                }

                if (state.gameStatus === 'GAME_OVER') {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.fillStyle = '#ef4444';
                    ctx.font = '80px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText("GAME OVER", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 50);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '30px sans-serif';
                    const minutes = Math.floor(state.survivalTime / 60);
                    const seconds = Math.floor(state.survivalTime % 60);
                    ctx.fillText(`Survived: ${minutes}m ${seconds}s`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
                }
            };

            return (
                <div className="w-screen h-screen bg-stone-900 flex items-center justify-center overflow-hidden">
                    <div className="scanline absolute inset-0 z-10 pointer-events-none"></div>
                    
                    {/* LOBBY */}
                    {status === 'LOBBY' && (
                        <div className="bg-stone-800 p-8 rounded-xl shadow-2xl border border-stone-700 w-[480px] max-w-full relative z-20">
                            <h1 className="text-4xl font-bold text-stone-100 mb-6 flex items-center gap-2">
                                <Shield className="w-8 h-8 text-blue-500"/> Police Escape <span className="text-sm text-stone-500 font-normal">Co-op</span>
                            </h1>
                            
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-stone-400 text-sm mb-1">Nickname</label>
                                    <input 
                                        type="text" 
                                        className="w-full bg-stone-900 border border-stone-700 rounded p-2 text-white focus:border-blue-500 outline-none transition"
                                        value={myName}
                                        onChange={(e) => setMyName(e.target.value)}
                                        placeholder="Officer Down"
                                    />
                                </div>

                                <div>
                                    <label className="block text-stone-400 text-sm mb-2">Color</label>
                                    <div className="flex gap-2">
                                        {Object.values(PlayerColor).map(c => (
                                            <div 
                                                key={c}
                                                onClick={() => setMyColor(c)}
                                                className={`w-10 h-10 rounded-full cursor-pointer border-2 ${myColor === c ? 'border-white scale-110' : 'border-transparent opacity-50 hover:opacity-100'}`}
                                                style={{ backgroundColor: c }}
                                            />
                                        ))}
                                    </div>
                                </div>

                                {role === 'HOST' && (
                                    <div className="bg-stone-900 p-4 rounded border border-stone-700 mt-4">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-stone-400 text-xs uppercase font-bold tracking-wider">Lobby ID</span>
                                            <button onClick={() => navigator.clipboard.writeText(myPeerId)} className="text-blue-400 hover:text-blue-300 text-xs flex items-center gap-1">
                                                <Copy size={12}/> Copy
                                            </button>
                                        </div>
                                        <div className="font-mono text-xl text-white break-all">{myPeerId || <Loader2 className="animate-spin"/>}</div>
                                        
                                        <div className="mt-4">
                                            <div className="text-stone-400 text-xs mb-2 flex items-center gap-2"><Users size={12}/> Players ({playersList.length}/4)</div>
                                            <div className="space-y-1">
                                                {playersList.map((p, i) => (
                                                    <div key={i} className="text-stone-300 text-sm flex items-center gap-2">
                                                        <div className="w-2 h-2 rounded-full" style={{backgroundColor: p.color}}></div>
                                                        {p.name} {p.id === myPeerId && '(You)'}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {role === 'CLIENT' && (
                                    <div className="bg-stone-900 p-4 rounded border border-stone-700 mt-4 text-center">
                                        <p className="text-stone-300 animate-pulse">Waiting for host to start...</p>
                                        <div className="mt-4 text-left">
                                            <div className="text-stone-400 text-xs mb-2 flex items-center gap-2"><Users size={12}/> Players in Lobby</div>
                                            {playersList.map((p, i) => (
                                                <div key={i} className="text-stone-300 text-sm flex items-center gap-2">
                                                    <div className="w-2 h-2 rounded-full" style={{backgroundColor: p.color}}></div>
                                                    {p.name} {p.id === myPeerId && '(You)'}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {!role && (
                                    <div className="grid grid-cols-2 gap-4 mt-6">
                                        <button 
                                            onClick={startHosting}
                                            disabled={!myPeerId}
                                            className="bg-blue-600 hover:bg-blue-500 text-white py-3 rounded font-bold transition disabled:opacity-50 flex justify-center items-center gap-2"
                                        >
                                            Host Game
                                        </button>
                                        <div className="flex flex-col gap-2">
                                            <input 
                                                type="text" 
                                                placeholder="Enter Host ID"
                                                value={hostId}
                                                onChange={(e) => setHostId(e.target.value)}
                                                className="bg-stone-900 border border-stone-700 rounded p-2 text-white text-sm outline-none"
                                            />
                                            <button 
                                                onClick={joinGame}
                                                disabled={!myPeerId || !hostId}
                                                className="bg-stone-700 hover:bg-stone-600 text-white py-2 rounded font-bold transition disabled:opacity-50 text-sm"
                                            >
                                                Join
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {role === 'HOST' && (
                                    <button 
                                        onClick={startGame}
                                        className="w-full mt-4 bg-green-600 hover:bg-green-500 text-white py-3 rounded font-bold shadow-lg shadow-green-900/50 transition"
                                    >
                                        START GAME
                                    </button>
                                )}
                            </div>
                        </div>
                    )}

                    {/* ABILITY SELECTION */}
                    {status === 'ABILITY_SELECTION' && (
                        <div className="fixed inset-0 bg-stone-900/90 z-30 flex flex-col items-center justify-center p-8">
                            <h2 className="text-3xl text-white font-bold mb-2">Choose Your Loadout</h2>
                            <p className="text-stone-400 mb-8">Every second counts. Pick a specialization.</p>
                            
                            <div className="grid grid-cols-3 gap-6 w-full max-w-3xl">
                                {offeredAbilities.map(key => {
                                    // Check if I have selected this
                                    const me = gameStateRef.current.players.find(p => p.peerId === myPeerId);
                                    const selected = me && me.selectedAbility === key;
                                    
                                    return (
                                        <AbilityCard 
                                            key={key}
                                            id={key}
                                            data={ABILITIES_DATA[key]}
                                            selected={selected}
                                            onSelect={selectAbility}
                                        />
                                    );
                                })}
                            </div>
                            
                            <div className="mt-8 text-stone-500 flex items-center gap-2">
                                <Loader2 className="animate-spin"/> Waiting for other players...
                            </div>
                        </div>
                    )}

                    {/* RESTART BUTTON (OVERLAY) */}
                    {showRestart && (
                        <div className="absolute bottom-20 left-1/2 -translate-x-1/2 z-50">
                            <button 
                                onClick={restartGame}
                                className="bg-white text-stone-900 px-8 py-4 rounded-full font-bold text-xl hover:scale-105 transition shadow-xl flex items-center gap-2"
                            >
                                <RotateCcw /> RESTART GAME
                            </button>
                        </div>
                    )}

                    {/* GAME CANVAS */}
                    <canvas 
                        ref={canvasRef}
                        width={CANVAS_WIDTH}
                        height={CANVAS_HEIGHT}
                        className={`shadow-2xl rounded-lg border-4 border-stone-800 bg-stone-900 ${status === 'LOBBY' ? 'hidden' : 'block'}`}
                        style={{ maxWidth: '100%', maxHeight: '100%' }}
                    />
                    
                    {/* CONTROLS HINT */}
                    {(status === 'PLAYING' || status === 'ABILITY_SELECTION') && (
                         <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-stone-500 text-xs font-mono bg-stone-900/80 px-4 py-1 rounded border border-stone-800 pointer-events-none z-40">
                            [WASD] Move  [SPACE] Rescue/Attack  [E] Ability
                         </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
