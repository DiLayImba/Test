
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Police Escape Co-op</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PeerJS (Global) & Babel -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1c1917; /* stone-900 */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: none;
        user-select: none;
      }
      canvas {
        touch-action: none;
      }
      /* Custom Scrollbar for chat/logs if needed */
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.344.0"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { User, Copy, Zap, Ghost, Snowflake, Shield, Bug, HeartPulse, Loader2, RotateCcw, Link as LinkIcon, Users } from 'lucide-react';

        // Access global PeerJS
        const Peer = window.Peer;

        // --- CONSTANTS & CONFIG ---
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const PLAYER_RADIUS = 15;
        const POLICE_RADIUS = 16;
        const PLAYER_SPEED = 4.8;
        const WALL_SIZE = 60;
        const WEB_RADIUS = 50;

        const POLICE_SPAWN_RATE = 5000;
        const POLICE_BASE_SPEED_RATIO = 0.4;
        const POLICE_MAX_SPEED_RATIO = 0.8;
        const POLICE_SPEED_GROWTH_INTERVAL = 5000;
        const ARREST_DURATION = 5000;
        const ATTACK_RADIUS = 70;
        const ATTACK_COOLDOWN = 500;
        const STUN_DURATION = 5000;
        const DASH_DISTANCE = PLAYER_RADIUS * 2 * 5;

        const PlayerColor = {
            GREEN: '#22c55e',
            PINK: '#ec4899',
            PURPLE: '#a855f7',
            BLACK: '#171717',
        };

        const ABILITIES_DATA = {
            DASH: { name: 'Dash', desc: 'Dash 5 body lengths forward.', cd: 10000 },
            INVISIBILITY: { name: 'Stealth', desc: 'Invisible to police for 5s.', cd: 30000 },
            FREEZE: { name: 'Freeze', desc: 'Stun all police for 2s.', cd: 40000 },
            WALL: { name: 'Barricade', desc: 'Drop a PERMANENT wall behind you.', cd: 20000 },
            WEB: { name: 'Spider Web', desc: 'Drop a PERMANENT slowing web.', cd: 30000 },
            SPEED: { name: 'Adrenaline', desc: 'Double speed for 5s.', cd: 60000 },
            SECOND_LIFE: { name: 'Second Chance', desc: 'Respawn once if eliminated.', cd: 0, passive: true },
            SHOCKER: { name: 'Shocker', desc: 'Break free from arrest.', cd: 60000 },
        };

        const INITIAL_GAME_STATE = {
            players: [],
            police: [],
            walls: [],
            webs: [],
            gameStatus: 'LOBBY',
            startTime: 0,
            survivalTime: 0,
            lastSpawnTime: 0,
            nextSpawnSide: 0,
            countdownValue: 3
        };

        // --- UTILS ---
        const distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

        const rectCircleColliding = (circle, rect) => {
            const distX = Math.abs(circle.x - rect.x - rect.w / 2);
            const distY = Math.abs(circle.y - rect.y - rect.h / 2);
            if (distX > (rect.w / 2 + circle.r)) return false;
            if (distY > (rect.h / 2 + circle.r)) return false;
            if (distX <= (rect.w / 2)) return true;
            if (distY <= (rect.h / 2)) return true;
            const dx = distX - rect.w / 2;
            const dy = distY - rect.h / 2;
            return (dx * dx + dy * dy <= (circle.r * circle.r));
        };

        const getSafeSpawn = (existingPlayers) => {
            const marginX = CANVAS_WIDTH * 0.25;
            const marginY = CANVAS_HEIGHT * 0.25;
            const safeWidth = CANVAS_WIDTH - (marginX * 2);
            const safeHeight = CANVAS_HEIGHT - (marginY * 2);
            
            let attempts = 0;
            let pos = { x: 0, y: 0 };
            let safe = false;

            while (!safe && attempts < 50) {
                pos.x = marginX + Math.random() * safeWidth;
                pos.y = marginY + Math.random() * safeHeight;
                safe = true;
                for (const p of existingPlayers) {
                    if (distance(pos.x, pos.y, p.x, p.y) < (PLAYER_RADIUS * 3)) {
                        safe = false;
                        break;
                    }
                }
                attempts++;
            }
            return pos;
        };

        // --- PHYSICS ENGINE ---
        const updatePhysics = (gameState, inputs) => {
            const newState = { ...gameState };
            const now = Date.now();

            if (newState.gameStatus === 'ABILITY_SELECTION') return newState;

            if (newState.gameStatus === 'COUNTDOWN') {
                const diff = now - newState.startTime;
                if (diff < 1000) newState.countdownValue = 3;
                else if (diff < 2000) newState.countdownValue = 2;
                else if (diff < 3000) newState.countdownValue = 1;
                else {
                    newState.gameStatus = 'PLAYING';
                    newState.startTime = now;
                    newState.lastSpawnTime = now;
                }
                return newState;
            }

            if (newState.gameStatus !== 'PLAYING') return newState;

            // 1. Update Players
            newState.players = newState.players.map(player => {
                if (player.isEliminated) return player;

                const input = inputs[player.peerId];
                if (!input) return player;

                // Captured / Shocker
                if (player.isCaptured) {
                    if (player.selectedAbility === 'SHOCKER' && input.ability && (!player.abilityCooldown || now > player.abilityCooldown)) {
                        player.abilityCooldown = now + ABILITIES_DATA.SHOCKER.cd;
                        player.isCaptured = false;
                        const cop = newState.police.find(p => p.id === player.capturedBy);
                        if (cop) {
                            cop.state = 'STUNNED';
                            cop.stunUntil = now + STUN_DURATION;
                            cop.draggingPlayerId = null;
                        }
                        player.capturedBy = null;
                    }
                    return player;
                }

                // Movement
                let currentSpeed = PLAYER_SPEED;
                const inWeb = newState.webs.some(w => distance(player.x, player.y, w.x, w.y) < WEB_RADIUS);
                if (inWeb) currentSpeed *= 0.2;
                if (player.speedBoostUntil && now < player.speedBoostUntil) currentSpeed *= 2;

                let dx = 0;
                let dy = 0;
                if (input.up) dy -= currentSpeed;
                if (input.down) dy += currentSpeed;
                if (input.left) dx -= currentSpeed;
                if (input.right) dx += currentSpeed;

                if (dx !== 0 && dy !== 0) {
                    dx *= 0.7071;
                    dy *= 0.7071;
                }

                // Direction
                let dirX = player.dirX;
                let dirY = player.dirY;
                if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    dirX = dx / mag;
                    dirY = dy / mag;
                }

                // Abilities
                if (input.ability && player.selectedAbility && (!player.abilityCooldown || now > player.abilityCooldown)) {
                    const ab = ABILITIES_DATA[player.selectedAbility];
                    let activated = false;

                    if (player.selectedAbility === 'DASH') {
                        let dashX = player.x + dirX * DASH_DISTANCE;
                        let dashY = player.y + dirY * DASH_DISTANCE;
                        dashX = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, dashX));
                        dashY = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, dashY));
                        player.x = dashX; 
                        player.y = dashY;
                        activated = true;
                    }
                    else if (player.selectedAbility === 'INVISIBILITY') {
                        player.invisibleUntil = now + 5000;
                        activated = true;
                    }
                    else if (player.selectedAbility === 'FREEZE') {
                        newState.police.forEach(p => { p.state = 'STUNNED'; p.stunUntil = now + 2000; });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'WALL') {
                        newState.walls.push({
                            id: `wall-${now}-${player.peerId}`,
                            x: player.x - (dirX * 40) - (WALL_SIZE/2),
                            y: player.y - (dirY * 40) - (WALL_SIZE/2),
                            w: WALL_SIZE,
                            h: WALL_SIZE
                        });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'WEB') {
                        newState.webs.push({
                            id: `web-${now}-${player.peerId}`,
                            x: player.x - (dirX * 40),
                            y: player.y - (dirY * 40)
                        });
                        activated = true;
                    }
                    else if (player.selectedAbility === 'SPEED') {
                        player.speedBoostUntil = now + 5000;
                        activated = true;
                    }

                    if (activated) player.abilityCooldown = now + ab.cd;
                }

                let newX = player.x + dx;
                let newY = player.y + dy;

                // Wall Collision
                for (const w of newState.walls) {
                    if (rectCircleColliding({x: newX, y: player.y, r: PLAYER_RADIUS}, w)) newX = player.x;
                    if (rectCircleColliding({x: player.x, y: newY, r: PLAYER_RADIUS}, w)) newY = player.y;
                }

                newX = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, newX));
                newY = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, newY));

                // Combat
                if (input.action && now - player.lastAttack > ATTACK_COOLDOWN) {
                    player.lastAttack = now;
                    newState.police.forEach(cop => {
                        if ((cop.state === 'DRAGGING' || cop.state === 'ARRESTING') && distance(newX, newY, cop.x, cop.y) < ATTACK_RADIUS) {
                            cop.state = 'STUNNED';
                            cop.stunUntil = now + STUN_DURATION;
                            const victim = newState.players.find(p => p.peerId === cop.draggingPlayerId);
                            if (victim) {
                                victim.isCaptured = false;
                                victim.capturedBy = null;
                            }
                            cop.draggingPlayerId = null;
                        }
                    });
                }

                return { ...player, x: newX, y: newY, dirX, dirY };
            });

            // 2. Player-Player Collision
            for(let i=0; i < newState.players.length; i++) {
                for(let j=i+1; j < newState.players.length; j++) {
                    const p1 = newState.players[i];
                    const p2 = newState.players[j];
                    if (p1.isEliminated || p2.isEliminated || p1.isCaptured || p2.isCaptured) continue;
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < PLAYER_RADIUS * 2 && dist > 0) {
                        const overlap = (PLAYER_RADIUS * 2 - dist) / 2;
                        const offX = (dx / dist) * overlap;
                        const offY = (dy / dist) * overlap;
                        p1.x += offX; p1.y += offY;
                        p2.x -= offX; p2.y -= offY;
                    }
                }
            }

            // 3. Spawn Police
            if (now - newState.lastSpawnTime > POLICE_SPAWN_RATE && newState.players.some(p => !p.isEliminated)) {
                newState.lastSpawnTime = now;
                const edge = newState.nextSpawnSide;
                let px, py;
                if (edge === 0) { px = Math.random() * CANVAS_WIDTH; py = -30; }
                else if (edge === 1) { px = CANVAS_WIDTH + 30; py = Math.random() * CANVAS_HEIGHT; }
                else if (edge === 2) { px = Math.random() * CANVAS_WIDTH; py = CANVAS_HEIGHT + 30; }
                else { px = -30; py = Math.random() * CANVAS_HEIGHT; }

                newState.police.push({
                    id: `police-${now}`,
                    x: px, y: py,
                    state: 'CHASING',
                    stunUntil: 0, arrestStartTime: 0, draggingPlayerId: null
                });
                newState.nextSpawnSide = Math.floor(Math.random() * 4);
            }

            // 4. Update Police
            const activePlayers = newState.players.filter(p => !p.isEliminated && !p.isCaptured);
            const visiblePlayers = activePlayers.filter(p => !p.invisibleUntil || now > p.invisibleUntil);
            
            const timePlayed = newState.survivalTime * 1000;
            const speedStage = Math.min(10, Math.floor(timePlayed / POLICE_SPEED_GROWTH_INTERVAL));
            const currentPoliceSpeedFactor = POLICE_BASE_SPEED_RATIO + (speedStage * 0.04);
            const basePoliceSpeed = Math.min(PLAYER_SPEED * POLICE_MAX_SPEED_RATIO, PLAYER_SPEED * currentPoliceSpeedFactor);

            newState.police = newState.police.map(cop => {
                if (cop.state === 'STUNNED') {
                    if (now > cop.stunUntil) cop.state = 'CHASING';
                    return cop;
                }

                let speed = basePoliceSpeed;
                if (newState.webs.some(w => distance(cop.x, cop.y, w.x, w.y) < WEB_RADIUS)) speed *= 0.2;

                let vx = 0, vy = 0;

                if (cop.state === 'EXITING') {
                    const angle = Math.atan2(cop.y - CANVAS_HEIGHT/2, cop.x - CANVAS_WIDTH/2);
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                }
                else if (cop.state === 'ARRESTING') {
                    if (now - cop.arrestStartTime > ARREST_DURATION) cop.state = 'DRAGGING';
                    if (cop.draggingPlayerId) {
                        const vIdx = newState.players.findIndex(p => p.peerId === cop.draggingPlayerId);
                        if (vIdx !== -1) { newState.players[vIdx].x = cop.x; newState.players[vIdx].y = cop.y; }
                    }
                    return cop;
                }
                else if (cop.state === 'DRAGGING') {
                    const distTop = cop.y;
                    const distBottom = CANVAS_HEIGHT - cop.y;
                    const distLeft = cop.x;
                    const distRight = CANVAS_WIDTH - cop.x;
                    const minDist = Math.min(distTop, distBottom, distLeft, distRight);
                    speed *= 0.5;

                    if (minDist === distTop) vy = -speed;
                    else if (minDist === distBottom) vy = speed;
                    else if (minDist === distLeft) vx = -speed;
                    else vx = speed;

                    if (cop.draggingPlayerId) {
                        const vIdx = newState.players.findIndex(p => p.peerId === cop.draggingPlayerId);
                        if (vIdx !== -1) {
                            const victim = newState.players[vIdx];
                            victim.x = cop.x; victim.y = cop.y;
                            
                            if (cop.x < 0 || cop.x > CANVAS_WIDTH || cop.y < 0 || cop.y > CANVAS_HEIGHT) {
                                if (victim.selectedAbility === 'SECOND_LIFE' && !victim.secondLifeUsed) {
                                    victim.secondLifeUsed = true;
                                    victim.isCaptured = false;
                                    victim.capturedBy = null;
                                    const pos = getSafeSpawn(newState.players);
                                    victim.x = pos.x; victim.y = pos.y;
                                    cop.state = 'EXITING';
                                    cop.draggingPlayerId = null;
                                } else {
                                    victim.isEliminated = true;
                                    victim.isCaptured = false;
                                    cop.state = 'EXITING';
                                    cop.draggingPlayerId = null;
                                }
                            }
                        } else cop.state = 'CHASING';
                    } else cop.state = 'CHASING';
                }
                else if (cop.state === 'CHASING') {
                    let nearest = null;
                    let minD = Infinity;
                    visiblePlayers.forEach(p => {
                        const d = distance(cop.x, cop.y, p.x, p.y);
                        if (d < minD) { minD = d; nearest = p; }
                    });

                    if (nearest) {
                        const angle = Math.atan2(nearest.y - cop.y, nearest.x - cop.x);
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;
                        
                        if (distance(cop.x, cop.y, nearest.x, nearest.y) < (POLICE_RADIUS + PLAYER_RADIUS)) {
                            cop.state = 'ARRESTING';
                            cop.arrestStartTime = now;
                            cop.draggingPlayerId = nearest.peerId;
                            const pIdx = newState.players.findIndex(p => p.peerId === nearest.peerId);
                            if (pIdx !== -1) {
                                newState.players[pIdx].isCaptured = true;
                                newState.players[pIdx].capturedBy = cop.id;
                                newState.players[pIdx].x = cop.x;
                                newState.players[pIdx].y = cop.y;
                            }
                            vx=0; vy=0;
                        }
                    } else {
                        const angle = Math.atan2(CANVAS_HEIGHT/2 - cop.y, CANVAS_WIDTH/2 - cop.x);
                        vx = Math.cos(angle) * (speed*0.5);
                        vy = Math.sin(angle) * (speed*0.5);
                    }
                }

                let nextX = cop.x + vx;
                let nextY = cop.y + vy;
                for (const w of newState.walls) {
                    if (rectCircleColliding({x: nextX, y: cop.y, r: POLICE_RADIUS}, w)) nextX = cop.x;
                    if (rectCircleColliding({x: cop.x, y: nextY, r: POLICE_RADIUS}, w)) nextY = cop.y;
                }

                return { ...cop, x: nextX, y: nextY };
            });

            // 5. Police Collision
            for(let iter=0; iter<2; iter++) {
                for (let i = 0; i < newState.police.length; i++) {
                    for (let j = i + 1; j < newState.police.length; j++) {
                        const p1 = newState.police[i];
                        const p2 = newState.police[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < POLICE_RADIUS * 2 && dist > 0) {
                            const overlap = (POLICE_RADIUS*2 - dist)/2;
                            const ox = (dx/dist)*overlap; const oy = (dy/dist)*overlap;
                            p1.x+=ox; p1.y+=oy; p2.x-=ox; p2.y-=oy;
                        }
                    }
                }
            }

            // Cleanup
            newState.police = newState.police.filter(cop => {
                if (cop.state === 'EXITING') return (cop.x > -100 && cop.x < CANVAS_WIDTH+100 && cop.y > -100 && cop.y < CANVAS_HEIGHT+100);
                return true;
            });

            const aliveCount = newState.players.filter(p => !p.isEliminated).length;
            if (newState.players.length > 0 && aliveCount === 0) newState.gameStatus = 'GAME_OVER';
            else newState.survivalTime = (now - newState.startTime) / 1000;

            return newState;
        };

        // --- COMPONENTS ---

        const AbilityIcon = ({ id, className }) => {
            switch(id) {
                case 'DASH': return <Zap className={className} />;
                case 'INVISIBILITY': return <Ghost className={className} />;
                case 'FREEZE': return <Snowflake className={className} />;
                case 'WALL': return <Shield className={className} />;
                case 'WEB': return <Bug className={className} />;
                case 'SPEED': return <Zap className={`text-yellow-400 ${className}`} />;
                case 'SECOND_LIFE': return <HeartPulse className={className} />;
                case 'SHOCKER': return <Zap className={`text-blue-400 ${className}`} />;
                default: return null;
            }
        };

        const GameCanvas = ({ gameState, myPeerId }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const render = () => {
                    const now = Date.now();
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Grid
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for(let x=0; x<CANVAS_WIDTH; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x,CANVAS_HEIGHT); }
                    for(let y=0; y<CANVAS_HEIGHT; y+=100) { ctx.moveTo(0,y); ctx.lineTo(CANVAS_WIDTH,y); }
                    ctx.stroke();

                    // Safe Zone
                    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                    ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                    ctx.strokeRect(CANVAS_WIDTH * 0.25, CANVAS_HEIGHT * 0.25, CANVAS_WIDTH * 0.5, CANVAS_HEIGHT * 0.5);
                    ctx.setLineDash([]);

                    // Walls
                    ctx.fillStyle = '#78716c'; ctx.strokeStyle = '#44403c'; ctx.lineWidth = 3;
                    gameState.walls.forEach(w => {
                        ctx.fillRect(w.x, w.y, w.w, w.h); ctx.strokeRect(w.x, w.y, w.w, w.h);
                        ctx.beginPath(); ctx.moveTo(w.x, w.y+w.h/2); ctx.lineTo(w.x+w.w, w.y+w.h/2); ctx.stroke();
                    });

                    // Webs
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1;
                    gameState.webs.forEach(w => {
                        ctx.save(); ctx.translate(w.x, w.y); ctx.beginPath();
                        for(let i=0; i<8; i++) {
                            const angle = (i/8)*Math.PI*2;
                            ctx.moveTo(0,0); ctx.lineTo(Math.cos(angle)*WEB_RADIUS, Math.sin(angle)*WEB_RADIUS);
                        }
                        ctx.arc(0,0, WEB_RADIUS/2, 0, Math.PI*2); ctx.arc(0,0, WEB_RADIUS, 0, Math.PI*2); ctx.stroke(); ctx.restore();
                    });

                    // Spawners
                    if (gameState.gameStatus === 'PLAYING') {
                         const side = gameState.nextSpawnSide;
                         ctx.fillStyle = `rgba(239, 68, 68, 0.4)`;
                         const barSize = 20;
                         if (side === 0) ctx.fillRect(0, 0, CANVAS_WIDTH, barSize);
                         else if (side === 1) ctx.fillRect(CANVAS_WIDTH - barSize, 0, barSize, CANVAS_HEIGHT);
                         else if (side === 2) ctx.fillRect(0, CANVAS_HEIGHT - barSize, CANVAS_WIDTH, barSize);
                         else if (side === 3) ctx.fillRect(0, 0, barSize, CANVAS_HEIGHT);
                    }

                    const entities = [
                        ...gameState.players.map(p => ({ type: 'player', y: p.y, obj: p })),
                        ...gameState.police.map(p => ({ type: 'police', y: p.y, obj: p }))
                    ];
                    entities.sort((a, b) => a.y - b.y);

                    entities.forEach(ent => {
                        const obj = ent.obj;
                        ctx.save(); ctx.translate(obj.x, obj.y);
                        if (ent.type === 'player') {
                            if (!obj.isEliminated) {
                                if (obj.invisibleUntil && now < obj.invisibleUntil) ctx.globalAlpha = 0.4;
                                ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(obj.name, 0, -25);
                                if (obj.peerId === myPeerId) {
                                    ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(0, -35); ctx.lineTo(-5, -45); ctx.lineTo(5, -45); ctx.fill();
                                }
                                if (obj.isCaptured) {
                                    ctx.strokeStyle = 'red'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0, PLAYER_RADIUS+5, 0, Math.PI*2); ctx.stroke();
                                    ctx.fillStyle = 'white'; ctx.fillText("HELP!", 0, -40);
                                }
                                ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI*2); ctx.fill();
                                ctx.lineWidth = 2; ctx.strokeStyle = 'white'; ctx.stroke();
                            }
                        } else {
                            ctx.fillStyle = '#1e3a8a'; ctx.beginPath(); ctx.arc(0, 0, POLICE_RADIUS, 0, Math.PI*2); ctx.fill();
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(0, -5, 14, 8, 0, Math.PI, 0); ctx.fill();
                            ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(3, 3); ctx.lineTo(0, 6); ctx.lineTo(-3, 3); ctx.fill();
                            if (obj.state === 'STUNNED') { ctx.fillStyle = 'yellow'; ctx.fillText("â˜…", 0, -20); }
                            if (obj.state === 'ARRESTING') {
                                const remaining = Math.max(0, 5000 - (now - obj.arrestStartTime));
                                ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0, POLICE_RADIUS+8, 0, (remaining/5000)*Math.PI*2); ctx.stroke();
                            }
                        }
                        ctx.restore();
                    });

                    ctx.textAlign = 'right'; ctx.fillStyle = 'white'; ctx.font = 'bold 24px monospace';
                    ctx.fillText(`SURVIVED: ${gameState.survivalTime.toFixed(1)}s`, CANVAS_WIDTH - 20, 40);

                    if (gameState.gameStatus === 'GAME_OVER') {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.fillStyle = '#ef4444'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center';
                        ctx.fillText("BUSTED!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                    }

                    if (gameState.gameStatus === 'COUNTDOWN') {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        ctx.fillStyle = '#fbbf24'; ctx.font = 'bold 120px monospace'; ctx.textAlign = 'center';
                        ctx.fillText(gameState.countdownValue.toString(), CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    }
                };
                render();
            }, [gameState, myPeerId]);

            return <canvas ref={canvasRef} width={CANVAS_WIDTH} height={CANVAS_HEIGHT} className="rounded-lg shadow-2xl cursor-crosshair border-4 border-slate-700" />;
        };

        const App = () => {
            const [mode, setMode] = useState('MENU');
            const [myPeerId, setMyPeerId] = useState('');
            const [isHost, setIsHost] = useState(false);
            const [playerName, setPlayerName] = useState('');
            const [selectedColor, setSelectedColor] = useState(null);
            const [hostIdInput, setHostIdInput] = useState('');
            const [isConnecting, setIsConnecting] = useState(false);
            const [abilityOptions, setAbilityOptions] = useState([]);
            const [selectedAbility, setSelectedAbility] = useState(null);
            const [errorMsg, setErrorMsg] = useState('');

            const gameStateRef = useRef(JSON.parse(JSON.stringify(INITIAL_GAME_STATE)));
            const [renderedGameState, setRenderedGameState] = useState(INITIAL_GAME_STATE);
            
            const peerRef = useRef(null);
            const connectionsRef = useRef(new Map());
            const isHostRef = useRef(false);
            const hostIdRef = useRef('');
            const requestRef = useRef();
            const inputsRef = useRef({});
            const myInputRef = useRef({ up: false, down: false, left: false, right: false, action: false, ability: false });
            const keysPressed = useRef(new Set());

            const COLORS = [
                { label: 'Green', value: PlayerColor.GREEN, bg: 'bg-green-500' },
                { label: 'Pink', value: PlayerColor.PINK, bg: 'bg-pink-500' },
                { label: 'Purple', value: PlayerColor.PURPLE, bg: 'bg-purple-500' },
                { label: 'Black', value: PlayerColor.BLACK, bg: 'bg-neutral-900' },
            ];

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const gameId = params.get('game');
                if (gameId) {
                    setHostIdInput(gameId);
                }

                const all = Object.keys(ABILITIES_DATA);
                const shuffled = all.sort(() => 0.5 - Math.random());
                setAbilityOptions(shuffled.slice(0, 3));
            }, []);

            const initializePeer = async () => {
                if (peerRef.current) return peerRef.current;
                return new Promise((resolve) => {
                    const newPeer = new Peer({ config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] } });
                    newPeer.on('open', (id) => { 
                        setMyPeerId(id); 
                        peerRef.current = newPeer; 
                        resolve(newPeer); 
                    });
                    newPeer.on('connection', handleIncomingConnection);
                    newPeer.on('error', (err) => {
                        console.error('Peer Error', err);
                        setErrorMsg('Connection error: ' + err.type);
                        setIsConnecting(false);
                    });
                });
            };

            const createGame = async () => {
                if (!playerName || !selectedColor) return;
                setIsConnecting(true);
                const peer = await initializePeer();
                setIsHost(true); isHostRef.current = true; setMode('LOBBY');
                const pos = getSafeSpawn([]);
                const hostPlayer = {
                    id: peer.id, peerId: peer.id, name: playerName, color: selectedColor,
                    x: pos.x, y: pos.y, isHost: true, dirX: 0, dirY: 1,
                    isCaptured: false, capturedBy: null, isEliminated: false, lastAttack: 0,
                    selectedAbility: null, abilityCooldown: 0
                };
                gameStateRef.current = { ...INITIAL_GAME_STATE, players: [hostPlayer], nextSpawnSide: Math.floor(Math.random()*4) };
                setRenderedGameState({...gameStateRef.current});
                setIsConnecting(false);
            };

            const handleIncomingConnection = (conn) => {
                conn.on('open', () => {
                    connectionsRef.current.set(conn.peer, conn);
                    // We don't send state yet, wait for Join Request
                    conn.on('data', (data) => handleNetworkMessage(conn.peer, data, conn));
                    conn.on('close', () => {
                        connectionsRef.current.delete(conn.peer);
                        gameStateRef.current.players = gameStateRef.current.players.filter(p => p.peerId !== conn.peer);
                    });
                });
            };

            const joinGame = async () => {
                if (!playerName || !selectedColor || !hostIdInput) return;
                setIsConnecting(true);
                setErrorMsg('');
                const peer = await initializePeer();
                setIsHost(false); isHostRef.current = false; hostIdRef.current = hostIdInput;
                
                const conn = peer.connect(hostIdInput);
                conn.on('open', () => {
                    connectionsRef.current.set(hostIdInput, conn);
                    conn.send({ type: 'JOIN_REQUEST', payload: { name: playerName, color: selectedColor } });
                });
                conn.on('data', (data) => {
                    if (data.type === 'GAME_STATE') {
                        gameStateRef.current = data.payload;
                        setRenderedGameState({...data.payload});
                        if (mode === 'MENU') setMode('LOBBY');
                        if ((data.payload.gameStatus === 'PLAYING' || data.payload.gameStatus === 'ABILITY_SELECTION') && mode !== 'GAME') setMode('GAME');
                    } else if (data.type === 'START_GAME') {
                        setMode('GAME');
                    } else if (data.type === 'ERROR') {
                        setErrorMsg(data.payload);
                        setIsConnecting(false);
                        conn.close();
                    }
                });
                conn.on('error', (err) => {
                    setErrorMsg("Connection failed.");
                    setIsConnecting(false);
                });
                // Timeout fallback
                setTimeout(() => {
                    if (isConnecting && mode === 'MENU') {
                        setIsConnecting(false);
                        setErrorMsg("Connection timed out or invalid Host ID.");
                    }
                }, 5000);
            };

            const startGame = () => {
                if (!isHost) return;
                const currentPlayers = gameStateRef.current.players;
                const newPlayers = [];
                currentPlayers.forEach(p => {
                    const pos = getSafeSpawn(newPlayers);
                    newPlayers.push({ 
                        ...p, x: pos.x, y: pos.y, 
                        isCaptured: false, isEliminated: false, capturedBy: null,
                        selectedAbility: null, abilityCooldown: 0, secondLifeUsed: false, dirX: 0, dirY: 1
                    });
                });
                gameStateRef.current.players = newPlayers;
                gameStateRef.current.police = []; gameStateRef.current.walls = []; gameStateRef.current.webs = [];
                gameStateRef.current.gameStatus = 'ABILITY_SELECTION';
                connectionsRef.current.forEach(c => c.open && c.send({ type: 'START_GAME', payload: {} }));
                setMode('GAME');
            };

            const restartGame = () => {
                if (!isHostRef.current) return;
                startGame();
            };

            const handleNetworkMessage = (senderId, msg, conn) => {
                if (isHostRef.current) {
                    if (msg.type === 'JOIN_REQUEST') {
                        const { name, color } = msg.payload;
                        
                        if (gameStateRef.current.players.length >= 4) {
                            conn.send({ type: 'ERROR', payload: 'Lobby is full!' });
                            return;
                        }
                        if (gameStateRef.current.players.some(p => p.color === color)) {
                            conn.send({ type: 'ERROR', payload: 'Color already taken!' });
                            return;
                        }

                        const pos = getSafeSpawn(gameStateRef.current.players);
                        gameStateRef.current.players.push({
                            id: senderId, peerId: senderId, name, color, x: pos.x, y: pos.y, isHost: false,
                            dirX: 0, dirY: 1, isCaptured: false, capturedBy: null, isEliminated: false, lastAttack: 0,
                            selectedAbility: null, abilityCooldown: 0
                        });
                        // Send updated state to everyone
                        const stateMsg = { type: 'GAME_STATE', payload: gameStateRef.current };
                        conn.send(stateMsg); // Send to new player
                        connectionsRef.current.forEach(c => c.open && c.send(stateMsg)); // Update others
                    }
                    else if (msg.type === 'INPUT') inputsRef.current[senderId] = msg.payload;
                    else if (msg.type === 'SELECT_ABILITY') {
                        const pIdx = gameStateRef.current.players.findIndex(p => p.peerId === senderId);
                        if (pIdx !== -1) gameStateRef.current.players[pIdx].selectedAbility = msg.payload.abilityId;
                    }
                }
            };

            const handleAbilitySelect = (abilityId) => {
                setSelectedAbility(abilityId);
                if (isHostRef.current) {
                    const pIdx = gameStateRef.current.players.findIndex(p => p.peerId === myPeerId);
                    if (pIdx !== -1) gameStateRef.current.players[pIdx].selectedAbility = abilityId;
                } else {
                    const hostConn = connectionsRef.current.get(hostIdRef.current);
                    if (hostConn) hostConn.send({ type: 'SELECT_ABILITY', payload: { abilityId }});
                }
            };

            const gameLoop = useCallback(() => {
                if (isHostRef.current) {
                    if (peerRef.current?.id) inputsRef.current[peerRef.current.id] = myInputRef.current;
                    
                    if (gameStateRef.current.gameStatus === 'ABILITY_SELECTION') {
                        const allSelected = gameStateRef.current.players.every(p => p.selectedAbility);
                        if (allSelected && gameStateRef.current.players.length > 0) {
                            gameStateRef.current.gameStatus = 'COUNTDOWN';
                            gameStateRef.current.startTime = Date.now();
                        }
                    } else if (gameStateRef.current.gameStatus !== 'GAME_OVER') {
                        gameStateRef.current = updatePhysics(gameStateRef.current, inputsRef.current);
                    }

                    connectionsRef.current.forEach(c => c.open && c.send({ type: 'GAME_STATE', payload: gameStateRef.current }));
                    setRenderedGameState({...gameStateRef.current});
                } else {
                    const hostConn = connectionsRef.current.get(hostIdRef.current);
                    if (hostConn && hostConn.open) hostConn.send({ type: 'INPUT', payload: myInputRef.current });
                }
                
                // Reset triggers
                if (myInputRef.current.action) myInputRef.current.action = false;
                if (myInputRef.current.ability) myInputRef.current.ability = false;
                Object.keys(inputsRef.current).forEach(k => {
                     if(inputsRef.current[k].action) inputsRef.current[k].action = false;
                     if(inputsRef.current[k].ability) inputsRef.current[k].ability = false;
                });

                requestRef.current = requestAnimationFrame(gameLoop);
            }, []);

            useEffect(() => {
                const handleKey = (e, isDown) => {
                    if (e.repeat) return;
                    isDown ? keysPressed.current.add(e.code) : keysPressed.current.delete(e.code);
                    myInputRef.current = {
                        up: keysPressed.current.has('ArrowUp') || keysPressed.current.has('KeyW'),
                        down: keysPressed.current.has('ArrowDown') || keysPressed.current.has('KeyS'),
                        left: keysPressed.current.has('ArrowLeft') || keysPressed.current.has('KeyA'),
                        right: keysPressed.current.has('ArrowRight') || keysPressed.current.has('KeyD'),
                        action: keysPressed.current.has('Space') || myInputRef.current.action,
                        ability: keysPressed.current.has('KeyE') || myInputRef.current.ability
                    };
                };
                window.addEventListener('keydown', (e) => handleKey(e, true));
                window.addEventListener('keyup', (e) => handleKey(e, false));
                return () => { window.removeEventListener('keydown', (e) => handleKey(e, true)); window.removeEventListener('keyup', (e) => handleKey(e, false)); };
            }, []);

            useEffect(() => {
                if (mode === 'LOBBY' || mode === 'GAME') {
                    if (!requestRef.current) requestRef.current = requestAnimationFrame(gameLoop);
                } else {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                }
            }, [mode, gameLoop]);

            const myPlayer = renderedGameState.players.find(p => p.peerId === myPeerId);

            const copyInviteLink = () => {
                const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?game=${myPeerId}`;
                navigator.clipboard.writeText(url);
            };

            if (mode === 'MENU') {
                return (
                    <div className="min-h-screen bg-stone-900 flex items-center justify-center p-4 font-mono">
                        <div className="max-w-md w-full bg-slate-800 rounded-xl border border-slate-700 shadow-2xl p-8 space-y-6">
                            <h1 className="text-4xl font-bold text-white text-center">POLICE ESCAPE</h1>
                            {errorMsg && <div className="bg-red-500/20 text-red-200 p-3 rounded text-center border border-red-500">{errorMsg}</div>}
                            <div className="space-y-4">
                                <input type="text" className="w-full p-2 bg-slate-900 border border-slate-700 text-white rounded" placeholder="Codename" value={playerName} onChange={(e) => setPlayerName(e.target.value)} />
                                <div className="grid grid-cols-4 gap-2">
                                    {COLORS.map(c => (
                                        <button key={c.value} onClick={() => setSelectedColor(c.value)} 
                                            className={`h-12 rounded-lg ${c.bg} ${selectedColor === c.value ? 'ring-4 ring-white' : 'opacity-70 hover:opacity-100'}`} />
                                    ))}
                                </div>
                                {isConnecting ? (
                                    <div className="flex items-center justify-center gap-2 text-blue-400 py-3"><Loader2 className="animate-spin"/> Connecting...</div>
                                ) : (
                                    <>
                                    <button onClick={createGame} disabled={!playerName || !selectedColor} className="w-full py-3 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white rounded font-bold transition-colors">CREATE LOBBY</button>
                                    <div className="flex gap-2">
                                        <input type="text" className="flex-1 p-2 bg-slate-900 text-white rounded border border-slate-700" placeholder="Host ID" value={hostIdInput} onChange={(e) => setHostIdInput(e.target.value)} />
                                        <button onClick={joinGame} disabled={!playerName || !selectedColor || !hostIdInput} className="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded font-bold transition-colors">JOIN</button>
                                    </div>
                                    </>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            if (mode === 'LOBBY') {
                const filledSlots = renderedGameState.players;
                const emptySlots = Array(4 - filledSlots.length).fill(null);

                return (
                    <div className="min-h-screen bg-slate-900 flex items-center justify-center p-4 font-mono text-white">
                        <div className="max-w-2xl w-full bg-slate-800 rounded-xl border border-slate-700 p-8">
                            <h2 className="text-3xl font-bold mb-6 text-center">TEAM LOBBY</h2>
                            
                            {isHost && (
                                <div className="mb-8 bg-slate-900 p-4 rounded-lg border border-slate-700">
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="text-slate-400 text-sm">LOBBY ID</span>
                                        <span className="text-slate-400 text-sm">INVITE LINK</span>
                                    </div>
                                    <div className="flex gap-4">
                                        <div className="flex-1 bg-black p-2 rounded flex justify-between items-center">
                                            <code className="text-green-400 truncate">{myPeerId}</code>
                                            <button onClick={() => navigator.clipboard.writeText(myPeerId)} className="hover:text-white text-slate-400"><Copy size={16}/></button>
                                        </div>
                                        <button onClick={copyInviteLink} className="px-4 bg-blue-600 hover:bg-blue-500 rounded text-sm font-bold flex items-center gap-2">
                                            <LinkIcon size={16}/> COPY LINK
                                        </button>
                                    </div>
                                </div>
                            )}

                            <div className="grid grid-cols-2 gap-4 mb-8">
                                {filledSlots.map(p => (
                                    <div key={p.id} className="flex items-center gap-3 p-4 bg-slate-700 rounded-lg border border-slate-600">
                                        <div className="w-10 h-10 rounded-full shadow-lg border-2 border-white/20" style={{ backgroundColor: p.color }}></div>
                                        <span className="font-bold text-lg">{p.name} {p.isHost && <span className="text-xs bg-yellow-500 text-black px-1 rounded ml-2">HOST</span>}</span>
                                    </div>
                                ))}
                                {emptySlots.map((_, i) => (
                                    <div key={`empty-${i}`} className="flex items-center gap-3 p-4 bg-slate-800/50 rounded-lg border border-slate-700 border-dashed">
                                        <div className="w-10 h-10 rounded-full bg-slate-800 border-2 border-slate-600 flex items-center justify-center">
                                            <Users size={20} className="text-slate-600"/>
                                        </div>
                                        <span className="text-slate-500 italic">Waiting for player...</span>
                                    </div>
                                ))}
                            </div>
                            
                            {isHost ? (
                                <button onClick={startGame} className="w-full py-4 bg-green-600 hover:bg-green-500 text-white rounded font-bold text-xl transition-colors shadow-lg shadow-green-900/20">
                                    START MISSION
                                </button>
                            ) : (
                                <div className="text-center p-4 bg-slate-900 rounded border border-slate-700 animate-pulse">
                                    Waiting for host to start mission...
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-stone-950 p-2 select-none relative overflow-hidden">
                    <GameCanvas gameState={renderedGameState} myPeerId={myPeerId} />

                    {renderedGameState.gameStatus === 'ABILITY_SELECTION' && (
                         <div className="absolute inset-0 bg-slate-900/95 z-50 flex flex-col items-center justify-center p-8 text-white">
                            <h2 className="text-4xl font-bold mb-8 text-yellow-400">CHOOSE POWER</h2>
                            <div className="flex gap-6 justify-center flex-wrap">
                                {abilityOptions.map(id => {
                                    const ab = ABILITIES_DATA[id];
                                    return (
                                        <button key={id} onClick={() => handleAbilitySelect(id)} className={`flex flex-col items-center p-6 w-64 rounded-xl border-2 transition-all ${selectedAbility === id ? 'bg-blue-900/50 border-blue-400 scale-105' : 'bg-slate-800 border-slate-700 hover:bg-slate-700'}`}>
                                            <div className="mb-4 p-4 rounded-full bg-slate-600"><AbilityIcon id={id} /></div>
                                            <h3 className="font-bold text-xl mb-2">{ab.name}</h3>
                                            <p className="text-sm text-slate-400 text-center">{ab.desc}</p>
                                        </button>
                                    )
                                })}
                            </div>
                            <div className="mt-12 h-8">{selectedAbility && <div className="flex items-center gap-2 text-blue-300 animate-pulse"><Loader2 className="animate-spin" size={20}/> Waiting for team...</div>}</div>
                         </div>
                    )}

                    {myPlayer && myPlayer.selectedAbility && (
                         <div className="absolute bottom-4 left-4 flex items-center gap-3 bg-slate-800/90 p-3 rounded-xl border border-slate-600 text-white">
                             <div className={`relative p-3 rounded-lg ${myPlayer.abilityCooldown > Date.now() ? 'bg-slate-700' : 'bg-blue-600'}`}>
                                 <AbilityIcon id={myPlayer.selectedAbility} />
                                 <div className="absolute -top-2 -right-2 bg-white text-black font-bold text-xs w-5 h-5 flex items-center justify-center rounded-full">E</div>
                                 {myPlayer.abilityCooldown > Date.now() && <div className="absolute inset-0 flex items-center justify-center bg-black/50 rounded-lg font-bold">{Math.ceil((myPlayer.abilityCooldown - Date.now())/1000)}</div>}
                             </div>
                             <div>
                                 <div className="font-bold text-sm">{ABILITIES_DATA[myPlayer.selectedAbility].name}</div>
                                 <div className="text-xs text-slate-400">{ABILITIES_DATA[myPlayer.selectedAbility].passive ? 'Passive' : 'Ready'}</div>
                             </div>
                         </div>
                    )}

                    {renderedGameState.gameStatus === 'GAME_OVER' && isHost && (
                        <div className="absolute bottom-10 pointer-events-auto animate-bounce">
                            <button onClick={restartGame} className="flex items-center gap-2 px-8 py-4 bg-blue-600 hover:bg-blue-500 text-white text-xl font-bold rounded-full shadow-xl"><RotateCcw size={24} /> RETRY MISSION</button>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
