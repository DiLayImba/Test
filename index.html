
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Police Escape Co-op</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- PeerJS for Networking -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1c1917; /* stone-900 */
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: none; /* Prevent pull-to-refresh on mobile */
        user-select: none;
      }
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; }
      ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "peerjs": "https://aistudiocdn.com/peerjs@^1.5.5",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // --- ICONS ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const User = (props) => <IconWrapper {...props}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></IconWrapper>;
        const Users = (props) => <IconWrapper {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconWrapper>;
        const Copy = (props) => <IconWrapper {...props}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></IconWrapper>;
        const Play = (props) => <IconWrapper {...props}><polygon points="5 3 19 12 5 21 5 3"/></IconWrapper>;
        const Info = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></IconWrapper>;
        const Loader2 = ({ className, ...props }) => <IconWrapper className={`animate-spin ${className}`} {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconWrapper>;
        const RotateCcw = (props) => <IconWrapper {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconWrapper>;
        const WifiOff = (props) => <IconWrapper {...props}><line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/><path d="M10.71 5.05A16 16 0 0 1 22.58 9"/><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></IconWrapper>;
        const LinkIcon = (props) => <IconWrapper {...props}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconWrapper>;
        const ShieldAlert = (props) => <IconWrapper {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M12 8v4"/><path d="M12 16h.01"/></IconWrapper>;

        // --- CONSTANTS & TYPES ---
        const PlayerColor = {
            GREEN: '#22c55e',
            PINK: '#ec4899',
            PURPLE: '#a855f7',
            BLACK: '#171717',
        };

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        // Reduced speed by ~20% (was 6)
        const PLAYER_SPEED = 4.8; 
        const PLAYER_RADIUS = 15;
        
        // Police Constants
        const POLICE_RADIUS = 16;
        const POLICE_SPAWN_RATE = 5000; // ms
        const POLICE_BASE_SPEED_RATIO = 0.4;
        const POLICE_MAX_SPEED_RATIO = 0.8;
        const POLICE_SPEED_GROWTH_INTERVAL = 5000;
        
        // Combat Constants
        const ATTACK_RADIUS = 70;
        const ATTACK_COOLDOWN = 500; // ms visual
        const STUN_DURATION = 5000;

        const INITIAL_GAME_STATE = {
            players: [],
            police: [],
            gameStatus: 'LOBBY',
            startTime: 0,
            survivalTime: 0,
            lastSpawnTime: 0,
            nextSpawnSide: 0, // 0: Top, 1: Right, 2: Bottom, 3: Left
        };

        const AVAILABLE_COLORS = [
            { label: 'Green', value: PlayerColor.GREEN, bg: 'bg-green-500' },
            { label: 'Pink', value: PlayerColor.PINK, bg: 'bg-pink-500' },
            { label: 'Purple', value: PlayerColor.PURPLE, bg: 'bg-purple-500' },
            { label: 'Black', value: PlayerColor.BLACK, bg: 'bg-neutral-900' },
        ];

        // --- GAME LOGIC ---
        const distance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        // Get random position safely inside canvas
        const getRandomSpawn = () => {
            return {
                x: 50 + Math.random() * (CANVAS_WIDTH - 100),
                y: 50 + Math.random() * (CANVAS_HEIGHT - 100)
            };
        };

        const updatePhysics = (gameState, inputs) => {
            const newState = { ...gameState };
            const now = Date.now();

            // Calculate dynamic police speed
            const timePlayed = newState.survivalTime * 1000;
            const speedStage = Math.min(10, Math.floor(timePlayed / POLICE_SPEED_GROWTH_INTERVAL));
            // Speed grows from 40% to 80% over time
            const currentPoliceSpeedFactor = POLICE_BASE_SPEED_RATIO + (speedStage * 0.04);
            const policeSpeed = Math.min(PLAYER_SPEED * POLICE_MAX_SPEED_RATIO, PLAYER_SPEED * currentPoliceSpeedFactor);

            // 1. Spawn Police
            if (now - newState.lastSpawnTime > POLICE_SPAWN_RATE && newState.players.some(p => !p.isEliminated)) {
                newState.lastSpawnTime = now;
                
                // Use the pre-determined side
                const edge = newState.nextSpawnSide;
                let px, py;
                
                if (edge === 0) { px = Math.random() * CANVAS_WIDTH; py = -30; } // Top
                else if (edge === 1) { px = CANVAS_WIDTH + 30; py = Math.random() * CANVAS_HEIGHT; } // Right
                else if (edge === 2) { px = Math.random() * CANVAS_WIDTH; py = CANVAS_HEIGHT + 30; } // Bottom
                else { px = -30; py = Math.random() * CANVAS_HEIGHT; } // Left

                newState.police.push({
                    id: `police-${now}`,
                    x: px,
                    y: py,
                    state: 'CHASING', // CHASING, DRAGGING, STUNNED, EXITING
                    targetId: null,
                    stunUntil: 0,
                    draggingPlayerId: null
                });

                // Pick NEXT side randomly
                newState.nextSpawnSide = Math.floor(Math.random() * 4);
            }

            // 2. Update Players (Movement & Attack)
            newState.players = newState.players.map(player => {
                if (player.isEliminated) return player;

                // If captured, physics is handled by the police dragging them
                if (player.isCaptured) return player;

                const input = inputs[player.peerId];
                if (!input) return player;

                // Movement
                let dx = 0;
                let dy = 0;
                if (input.up) dy -= PLAYER_SPEED;
                if (input.down) dy += PLAYER_SPEED;
                if (input.left) dx -= PLAYER_SPEED;
                if (input.right) dx += PLAYER_SPEED;

                if (dx !== 0 && dy !== 0) {
                    dx *= 0.7071;
                    dy *= 0.7071;
                }

                let newX = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, player.x + dx));
                let newY = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, player.y + dy));

                // Attack Logic
                let lastAttack = player.lastAttack || 0;
                if (input.action && now - lastAttack > ATTACK_COOLDOWN) {
                    lastAttack = now;
                    // Check for rescue
                    newState.police.forEach(cop => {
                        if (cop.state === 'DRAGGING' && distance(newX, newY, cop.x, cop.y) < ATTACK_RADIUS) {
                            cop.state = 'STUNNED';
                            cop.stunUntil = now + STUN_DURATION;
                            
                            // Free the victim
                            const victim = newState.players.find(p => p.peerId === cop.draggingPlayerId);
                            if (victim) {
                                victim.isCaptured = false;
                                victim.capturedBy = null;
                            }
                            cop.draggingPlayerId = null;
                        }
                    });
                }

                return { ...player, x: newX, y: newY, lastAttack };
            });

            // 2.5 Player-Player Collision (Separation)
            for(let i=0; i < newState.players.length; i++) {
                for(let j=i+1; j < newState.players.length; j++) {
                    const p1 = newState.players[i];
                    const p2 = newState.players[j];

                    // Skip eliminated
                    if (p1.isEliminated || p2.isEliminated) continue;
                    // Captured players don't push active players (they are being dragged)
                    if (p1.isCaptured || p2.isCaptured) continue;

                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = PLAYER_RADIUS * 2;

                    if (dist < minDist && dist > 0) {
                        const overlap = (minDist - dist) / 2;
                        const offsetX = (dx / dist) * overlap;
                        const offsetY = (dy / dist) * overlap;

                        // Push apart
                        p1.x += offsetX;
                        p1.y += offsetY;
                        p2.x -= offsetX;
                        p2.y -= offsetY;

                        // Clamp to bounds again just in case
                        p1.x = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, p1.x));
                        p1.y = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, p1.y));
                        p2.x = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, p2.x));
                        p2.y = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, p2.y));
                    }
                }
            }

            // 3. Update Police Physics & AI
            const activePlayers = newState.players.filter(p => !p.isEliminated && !p.isCaptured);

            newState.police = newState.police.map(cop => {
                if (cop.state === 'STUNNED') {
                    if (now > cop.stunUntil) {
                        cop.state = 'CHASING';
                    }
                    return cop;
                }

                let vx = 0; 
                let vy = 0;
                let speed = policeSpeed;

                if (cop.state === 'EXITING') {
                    const angle = Math.atan2(cop.y - CANVAS_HEIGHT/2, cop.x - CANVAS_WIDTH/2);
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                }
                else if (cop.state === 'DRAGGING') {
                    // Dragging player to nearest edge
                    const distTop = cop.y;
                    const distBottom = CANVAS_HEIGHT - cop.y;
                    const distLeft = cop.x;
                    const distRight = CANVAS_WIDTH - cop.x;
                    const minDist = Math.min(distTop, distBottom, distLeft, distRight);

                    // Reduced speed when dragging (50% of current police speed)
                    speed = speed * 0.5; 
                    
                    if (minDist === distTop) vy = -speed;
                    else if (minDist === distBottom) vy = speed;
                    else if (minDist === distLeft) vx = -speed;
                    else vx = speed;

                    // Update captured player position
                    if (cop.draggingPlayerId) {
                        const victimIndex = newState.players.findIndex(p => p.peerId === cop.draggingPlayerId);
                        if (victimIndex !== -1) {
                            newState.players[victimIndex].x = cop.x;
                            newState.players[victimIndex].y = cop.y;

                            if (cop.x < 0 || cop.x > CANVAS_WIDTH || cop.y < 0 || cop.y > CANVAS_HEIGHT) {
                                newState.players[victimIndex].isEliminated = true;
                                newState.players[victimIndex].isCaptured = false;
                                cop.state = 'EXITING';
                                cop.draggingPlayerId = null;
                            }
                        } else {
                             cop.state = 'CHASING';
                        }
                    } else {
                        cop.state = 'CHASING';
                    }
                }
                else if (cop.state === 'CHASING') {
                    let nearest = null;
                    let minD = Infinity;

                    activePlayers.forEach(p => {
                        const d = distance(cop.x, cop.y, p.x, p.y);
                        if (d < minD) {
                            minD = d;
                            nearest = p;
                        }
                    });

                    if (nearest) {
                        const angle = Math.atan2(nearest.y - cop.y, nearest.x - cop.x);
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;

                        if (distance(cop.x, cop.y, nearest.x, nearest.y) < (POLICE_RADIUS + PLAYER_RADIUS)) {
                            cop.state = 'DRAGGING';
                            cop.draggingPlayerId = nearest.peerId;
                            const pIdx = newState.players.findIndex(p => p.peerId === nearest.peerId);
                            if (pIdx !== -1) {
                                newState.players[pIdx].isCaptured = true;
                                newState.players[pIdx].capturedBy = cop.id;
                            }
                            vx = 0; vy = 0; 
                        }
                    } else {
                        const angle = Math.atan2(CANVAS_HEIGHT/2 - cop.y, CANVAS_WIDTH/2 - cop.x);
                        vx = Math.cos(angle) * (speed * 0.5);
                        vy = Math.sin(angle) * (speed * 0.5);
                    }
                }

                return { ...cop, x: cop.x + vx, y: cop.y + vy };
            });

            // 4. Police-Police Collision
            for(let iter=0; iter<2; iter++) {
                for (let i = 0; i < newState.police.length; i++) {
                    for (let j = i + 1; j < newState.police.length; j++) {
                        const p1 = newState.police[i];
                        const p2 = newState.police[j];
                        
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const minDist = POLICE_RADIUS * 2;

                        if (dist < minDist && dist > 0) {
                            const overlap = (minDist - dist) / 2;
                            const offsetX = (dx / dist) * overlap;
                            const offsetY = (dy / dist) * overlap;

                            p1.x += offsetX;
                            p1.y += offsetY;
                            p2.x -= offsetX;
                            p2.y -= offsetY;
                        }
                    }
                }
            }

            // Cleanup exiting police
            newState.police = newState.police.filter(cop => {
                if (cop.state === 'EXITING') {
                    return (cop.x > -100 && cop.x < CANVAS_WIDTH + 100 && cop.y > -100 && cop.y < CANVAS_HEIGHT + 100);
                }
                return true;
            });

            // 5. Game Status
            const aliveCount = newState.players.filter(p => !p.isEliminated).length;
            if (newState.players.length > 0 && aliveCount === 0) {
                newState.gameStatus = 'GAME_OVER';
            } else {
                 newState.survivalTime = (now - newState.startTime) / 1000;
            }

            return newState;
        };

        // --- CANVAS COMPONENT ---
        const GameCanvas = ({ gameState, myPeerId }) => {
            const canvasRef = useRef(null);

            const drawSpawnWarning = (ctx, side) => {
                const time = Date.now();
                const opacity = 0.2 + (Math.sin(time / 200) + 1) * 0.2; // Pulse 0.2 - 0.6
                ctx.fillStyle = `rgba(239, 68, 68, ${opacity})`;
                
                // 0: top, 1: right, 2: bottom, 3: left
                const barSize = 20;
                if (side === 0) ctx.fillRect(0, 0, CANVAS_WIDTH, barSize);
                else if (side === 1) ctx.fillRect(CANVAS_WIDTH - barSize, 0, barSize, CANVAS_HEIGHT);
                else if (side === 2) ctx.fillRect(0, CANVAS_HEIGHT - barSize, CANVAS_WIDTH, barSize);
                else if (side === 3) ctx.fillRect(0, 0, barSize, CANVAS_HEIGHT);
            };

            const drawPlayer = (ctx, player, now) => {
                if (player.isEliminated) return; 

                ctx.save();
                ctx.translate(player.x, player.y);

                // Label
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, 0, -25);
                
                if (player.peerId === myPeerId) {
                    ctx.fillStyle = '#FFD700'; // Gold marker for self
                    ctx.beginPath();
                    ctx.moveTo(0, -35);
                    ctx.lineTo(-5, -45);
                    ctx.lineTo(5, -45);
                    ctx.fill();
                }

                // Attack Animation (Swing)
                if (player.lastAttack && (now - player.lastAttack < 300)) {
                    const progress = (now - player.lastAttack) / 300;
                    ctx.save();
                    ctx.rotate(progress * Math.PI); 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(25, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                // Captured State
                if (player.isCaptured) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0,0, PLAYER_RADIUS + 5, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.fillText("HELP!", 0, -40);
                }

                // Body
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                
                // Outline
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'white';
                ctx.stroke();

                ctx.restore();
            };

            const drawPolice = (ctx, cop, now) => {
                ctx.save();
                ctx.translate(cop.x, cop.y);

                // Uniform Blue
                ctx.fillStyle = '#1e3a8a'; // Dark Blue
                ctx.beginPath();
                ctx.arc(0, 0, POLICE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Hat Brim
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, -5, 14, 8, 0, Math.PI, 0);
                ctx.fill();

                // Badge
                ctx.fillStyle = '#fbbf24'; // Gold
                ctx.beginPath();
                ctx.moveTo(0, -2);
                ctx.lineTo(3, 3);
                ctx.lineTo(0, 6);
                ctx.lineTo(-3, 3);
                ctx.fill();

                // Stunned Effect
                if (cop.state === 'STUNNED') {
                    ctx.fillStyle = 'yellow';
                    const angle = (now / 200) % (Math.PI * 2);
                    for(let i=0; i<3; i++) {
                        const a = angle + (i * (Math.PI*2/3));
                        ctx.fillText("★", Math.cos(a)*20, Math.sin(a)*20 - 10);
                    }
                }

                ctx.restore();
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const render = () => {
                    const now = Date.now();
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Dark asphalt background
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Grid lines
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for(let x=0; x<CANVAS_WIDTH; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x,CANVAS_HEIGHT); }
                    for(let y=0; y<CANVAS_HEIGHT; y+=100) { ctx.moveTo(0,y); ctx.lineTo(CANVAS_WIDTH,y); }
                    ctx.stroke();

                    // Spawn Warning
                    if (gameState.gameStatus === 'PLAYING') {
                        drawSpawnWarning(ctx, gameState.nextSpawnSide);
                    }

                    // Danger Zones (Edges)
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)'; // Red
                    ctx.lineWidth = 10;
                    ctx.strokeRect(0,0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Entities
                    const entities = [
                        ...gameState.players.map(p => ({ type: 'player', y: p.y, obj: p })),
                        ...gameState.police.map(p => ({ type: 'police', y: p.y, obj: p }))
                    ];
                    entities.sort((a, b) => a.y - b.y);

                    entities.forEach(ent => {
                        if (ent.type === 'player') drawPlayer(ctx, ent.obj, now);
                        else drawPolice(ctx, ent.obj, now);
                    });
                    
                    // HUD
                    ctx.textAlign = 'right';
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 24px monospace';
                    ctx.fillText(`SURVIVED: ${gameState.survivalTime.toFixed(1)}s`, CANVAS_WIDTH - 20, 40);

                    // Controls hint
                    ctx.textAlign = 'left';
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#cbd5e1';
                    ctx.fillText("SPACE: Rescue captured friends!", 20, 40);

                    if (gameState.gameStatus === 'GAME_OVER') {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        
                        ctx.fillStyle = '#ef4444';
                        ctx.font = 'bold 60px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText("BUSTED!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                        
                        ctx.fillStyle = 'white';
                        ctx.font = '30px monospace';
                        ctx.fillText(`Total Time: ${gameState.survivalTime.toFixed(2)}s`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
                    }
                };

                render();

            }, [gameState, myPeerId]);

            return (
                <canvas 
                ref={canvasRef} 
                width={CANVAS_WIDTH} 
                height={CANVAS_HEIGHT} 
                className="rounded-lg shadow-2xl cursor-crosshair touch-none border-4 border-slate-700"
                />
            );
        };

        // --- APP COMPONENT ---
        const App = () => {
            const [mode, setMode] = useState('MENU');
            const [myPeerId, setMyPeerId] = useState('');
            const [isHost, setIsHost] = useState(false);
            
            const [playerName, setPlayerName] = useState('');
            const [selectedColor, setSelectedColor] = useState(null);
            const [hostIdInput, setHostIdInput] = useState('');
            const [joinError, setJoinError] = useState('');
            const [isConnecting, setIsConnecting] = useState(false);
            const [statusMsg, setStatusMsg] = useState('');

            const gameStateRef = useRef(JSON.parse(JSON.stringify(INITIAL_GAME_STATE)));
            const [renderedGameState, setRenderedGameState] = useState(INITIAL_GAME_STATE);
            
            const peerRef = useRef(null);
            const connectionsRef = useRef(new Map());
            const isHostRef = useRef(false);
            const hostIdRef = useRef('');
            const requestRef = useRef();
            
            const inputsRef = useRef({});
            const myInputRef = useRef({ up: false, down: false, left: false, right: false, action: false });
            const keysPressed = useRef(new Set());

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const hostParam = params.get('host');
                if (hostParam) setHostIdInput(hostParam);

                return () => {
                    if (peerRef.current) peerRef.current.destroy();
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, []);

            const initializePeer = async () => {
                return new Promise((resolve, reject) => {
                    setStatusMsg('Initializing Network...');
                    const newPeer = new window.Peer({
                        debug: 1,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' },
                                { urls: 'stun:stun2.l.google.com:19302' },
                                { urls: 'stun:stun3.l.google.com:19302' },
                                { urls: 'stun:stun4.l.google.com:19302' },
                            ]
                        }
                    });
                    
                    newPeer.on('open', (id) => {
                        setMyPeerId(id);
                        peerRef.current = newPeer;
                        resolve(newPeer);
                    });

                    newPeer.on('error', (err) => {
                        console.error('Peer error:', err);
                        setJoinError("Connection Failed. Refresh and try again.");
                        setIsConnecting(false);
                        setStatusMsg('');
                    });

                    newPeer.on('connection', (conn) => {
                        handleIncomingConnection(conn);
                    });
                });
            };

            const createGame = async () => {
                if (!playerName || !selectedColor) return;
                setIsConnecting(true);
                
                try {
                    const peer = await initializePeer();
                    setIsHost(true);
                    isHostRef.current = true;
                    setMode('LOBBY');

                    const pos = getRandomSpawn();
                    const hostPlayer = {
                        id: peer.id,
                        peerId: peer.id,
                        name: playerName,
                        color: selectedColor,
                        x: pos.x,
                        y: pos.y,
                        isHost: true,
                        isCaptured: false,
                        isEliminated: false,
                        capturedBy: null,
                        lastAttack: 0
                    };

                    gameStateRef.current = {
                        ...INITIAL_GAME_STATE,
                        players: [hostPlayer],
                        nextSpawnSide: Math.floor(Math.random() * 4)
                    };
                    setRenderedGameState({...gameStateRef.current});
                } catch (e) {
                    setJoinError("Failed to host");
                } finally {
                    setIsConnecting(false);
                }
            };

            const handleIncomingConnection = (conn) => {
                conn.on('open', () => {
                    connectionsRef.current.set(conn.peer, conn);
                    conn.send({ type: 'GAME_STATE', payload: gameStateRef.current });
                    conn.on('data', (data) => handleNetworkMessage(conn.peer, data));
                    conn.on('close', () => {
                        connectionsRef.current.delete(conn.peer);
                        gameStateRef.current.players = gameStateRef.current.players.filter(p => p.peerId !== conn.peer);
                    });
                });
            };

            const startGame = () => {
                if (!isHost) return;
                gameStateRef.current.gameStatus = 'PLAYING';
                gameStateRef.current.startTime = Date.now();
                gameStateRef.current.lastSpawnTime = Date.now();
                // Reset positions on start? Or keep lobby positions. 
                // Let's keep lobby positions for now, or re-randomize?
                // Randomize again to be fair.
                gameStateRef.current.players.forEach(p => {
                    const pos = getRandomSpawn();
                    p.x = pos.x;
                    p.y = pos.y;
                });
                
                broadcast({ type: 'START_GAME', payload: {} });
                setMode('GAME');
            };

            const restartGame = () => {
                if (!isHostRef.current) return;
                
                const resetPlayers = gameStateRef.current.players.map((p) => {
                    const pos = getRandomSpawn();
                    return {
                        ...p,
                        x: pos.x,
                        y: pos.y,
                        isCaptured: false,
                        isEliminated: false,
                        capturedBy: null,
                    };
                });

                const newGameState = {
                    ...INITIAL_GAME_STATE,
                    players: resetPlayers,
                    gameStatus: 'PLAYING',
                    startTime: Date.now(),
                    lastSpawnTime: Date.now(),
                    nextSpawnSide: Math.floor(Math.random() * 4)
                };

                gameStateRef.current = newGameState;
                setRenderedGameState({...newGameState});
                broadcast({ type: 'GAME_STATE', payload: newGameState });
            };

            const joinGame = async () => {
                if (!playerName || !selectedColor || !hostIdInput) return;
                setIsConnecting(true);
                setStatusMsg('Connecting...');

                try {
                    const peer = await initializePeer();
                    setIsHost(false);
                    isHostRef.current = false;
                    hostIdRef.current = hostIdInput;

                    const conn = peer.connect(hostIdInput, { reliable: true });
                    
                    const connectionTimeout = setTimeout(() => {
                        if (!conn.open) {
                            setJoinError("Host unresponsive. Check ID.");
                            setIsConnecting(false);
                        }
                    }, 15000);

                    conn.on('open', () => {
                        clearTimeout(connectionTimeout);
                        connectionsRef.current.set(hostIdInput, conn);
                        conn.send({ 
                            type: 'JOIN_REQUEST', 
                            payload: { name: playerName, color: selectedColor } 
                        });
                    });

                    conn.on('data', (data) => {
                        if (data.type === 'GAME_STATE') {
                            gameStateRef.current = data.payload;
                            setRenderedGameState({...data.payload});
                            if (mode === 'MENU') {
                                setMode('LOBBY');
                                setIsConnecting(false);
                            }
                            if (data.payload.gameStatus === 'PLAYING' && mode !== 'GAME') setMode('GAME');
                        } else if (data.type === 'START_GAME') {
                            setMode('GAME');
                        }
                    });

                    conn.on('error', (err) => {
                        clearTimeout(connectionTimeout);
                        setJoinError("Connection error.");
                        setIsConnecting(false);
                    });
                    
                    conn.on('close', () => window.location.reload());

                } catch (e) {
                    setJoinError("Failed to join");
                    setIsConnecting(false);
                }
            };

            const handleNetworkMessage = (senderId, msg) => {
                if (isHostRef.current) {
                    if (msg.type === 'JOIN_REQUEST') {
                        const { name, color } = msg.payload;
                        if (gameStateRef.current.players.some(p => p.color === color)) return;
                        if (gameStateRef.current.players.length >= 4) return;

                        const pos = getRandomSpawn();
                        const newPlayer = {
                            id: senderId,
                            peerId: senderId,
                            name,
                            color,
                            x: pos.x,
                            y: pos.y,
                            isHost: false,
                            isCaptured: false,
                            isEliminated: false,
                            capturedBy: null,
                            lastAttack: 0
                        };
                        
                        gameStateRef.current.players.push(newPlayer);
                        broadcast({ type: 'GAME_STATE', payload: gameStateRef.current });
                    }
                    else if (msg.type === 'INPUT') {
                        inputsRef.current[senderId] = msg.payload;
                    }
                }
            };

            const broadcast = (msg) => {
                connectionsRef.current.forEach(conn => {
                    if (conn.open) conn.send(msg);
                });
            };

            const gameLoop = useCallback(() => {
                if (isHostRef.current) {
                    if (peerRef.current?.id) inputsRef.current[peerRef.current.id] = myInputRef.current;
                    
                    if (gameStateRef.current.gameStatus !== 'GAME_OVER') {
                        gameStateRef.current = updatePhysics(gameStateRef.current, inputsRef.current);
                    }
                    broadcast({ type: 'GAME_STATE', payload: gameStateRef.current });
                    setRenderedGameState({...gameStateRef.current});
                } else {
                    const hostConn = connectionsRef.current.get(hostIdRef.current);
                    if (hostConn && hostConn.open) hostConn.send({ type: 'INPUT', payload: myInputRef.current });
                }

                // Clear trigger
                if (myInputRef.current.action) myInputRef.current.action = false;
                Object.keys(inputsRef.current).forEach(k => {
                    if (inputsRef.current[k].action) inputsRef.current[k].action = false;
                });

                requestRef.current = requestAnimationFrame(gameLoop);
            }, []);

            useEffect(() => {
                if (mode === 'LOBBY' || mode === 'GAME') {
                    if (!requestRef.current) requestRef.current = requestAnimationFrame(gameLoop);
                } else {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                }
            }, [mode, gameLoop]);

            useEffect(() => {
                const handleKey = (e, isDown) => {
                    if (e.repeat) return;
                    isDown ? keysPressed.current.add(e.code) : keysPressed.current.delete(e.code);
                    myInputRef.current = {
                        up: keysPressed.current.has('ArrowUp') || keysPressed.current.has('KeyW'),
                        down: keysPressed.current.has('ArrowDown') || keysPressed.current.has('KeyS'),
                        left: keysPressed.current.has('ArrowLeft') || keysPressed.current.has('KeyA'),
                        right: keysPressed.current.has('ArrowRight') || keysPressed.current.has('KeyD'),
                        action: keysPressed.current.has('Space') || myInputRef.current.action
                    };
                };
                window.addEventListener('keydown', (e) => handleKey(e, true));
                window.addEventListener('keyup', (e) => handleKey(e, false));
                return () => {
                    window.removeEventListener('keydown', handleKey);
                    window.removeEventListener('keyup', handleKey);
                };
            }, []);

            const copyInviteLink = () => {
                const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?host=${myPeerId}`;
                navigator.clipboard.writeText(url);
                alert("Link copied!");
            };

            if (mode === 'MENU') {
                return (
                    <div className="min-h-screen bg-stone-900 flex items-center justify-center p-4 font-mono">
                        <div className="max-w-md w-full bg-slate-800 rounded-xl border border-slate-700 shadow-2xl p-8 space-y-6">
                        <div className="text-center space-y-2">
                            <div className="flex justify-center mb-2"><ShieldAlert size={48} className="text-red-500"/></div>
                            <h1 className="text-4xl font-bold text-white tracking-tighter">POLICE ESCAPE</h1>
                            <p className="text-slate-400">Survive together or get busted.</p>
                        </div>

                        <div className="space-y-4">
                            <div>
                            <label className="block text-sm font-medium text-slate-300 mb-1">CODENAME</label>
                            <input 
                                type="text" 
                                className="w-full p-2 bg-slate-900 border border-slate-700 text-white rounded-md focus:ring-2 focus:ring-blue-500 outline-none"
                                placeholder="Enter name"
                                value={playerName}
                                onChange={(e) => setPlayerName(e.target.value)}
                            />
                            </div>

                            <div>
                            <label className="block text-sm font-medium text-slate-300 mb-2">TEAM COLOR</label>
                            <div className="flex justify-between gap-2">
                                {AVAILABLE_COLORS.map(c => (
                                <button
                                    key={c.value}
                                    onClick={() => setSelectedColor(c.value)}
                                    className={`w-12 h-12 rounded-full ${c.bg} transition-transform hover:scale-110 ${selectedColor === c.value ? 'ring-4 ring-offset-2 ring-slate-500 scale-110' : ''}`}
                                />
                                ))}
                            </div>
                            </div>

                            <div className="pt-4 border-t border-slate-700 space-y-3">
                            {isConnecting ? (
                                <div className="flex flex-col items-center py-4 text-blue-400 gap-2">
                                    <Loader2 className="animate-spin" size={32} />
                                    <span className="text-sm">{statusMsg}</span>
                                </div>
                            ) : (
                                <>
                                    <button 
                                        onClick={createGame}
                                        disabled={!playerName || !selectedColor}
                                        className="w-full py-3 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50 transition-all shadow-lg shadow-blue-900/50"
                                    >
                                        CREATE LOBBY
                                    </button>
                                    
                                    <div className="relative py-2">
                                        <div className="absolute inset-0 flex items-center"><div className="w-full border-t border-slate-700"></div></div>
                                        <div className="relative flex justify-center text-xs"><span className="px-2 bg-slate-800 text-slate-500">OR JOIN SQUAD</span></div>
                                    </div>

                                    <div className="flex gap-2">
                                        <input 
                                        type="text" 
                                        className="flex-1 p-2 bg-slate-900 border border-slate-700 text-white rounded-md text-sm font-mono"
                                        placeholder="Paste ID here"
                                        value={hostIdInput}
                                        onChange={(e) => setHostIdInput(e.target.value)}
                                        />
                                        <button 
                                        onClick={joinGame}
                                        disabled={!playerName || !selectedColor || !hostIdInput}
                                        className="px-6 bg-slate-700 text-white rounded-lg font-bold hover:bg-slate-600 disabled:opacity-50"
                                        >
                                        JOIN
                                        </button>
                                    </div>
                                </>
                            )}
                            {joinError && (
                                <div className="p-3 bg-red-900/50 border border-red-700 rounded text-red-200 text-sm flex items-center gap-2">
                                    <WifiOff size={16} />
                                    <span>{joinError}</span>
                                </div>
                            )}
                            </div>
                        </div>
                        </div>
                    </div>
                );
            }

            if (mode === 'LOBBY') {
                return (
                    <div className="min-h-screen bg-slate-900 flex items-center justify-center p-4 font-mono">
                        <div className="max-w-2xl w-full bg-slate-800 rounded-xl border border-slate-700 shadow-xl p-8 text-white">
                        <h2 className="text-3xl font-bold mb-6 text-center">PRE-GAME LOBBY</h2>
                        
                        {isHost && (
                            <div className="mb-6 space-y-3">
                                <div className="p-4 bg-slate-900/50 rounded-lg border border-slate-700 flex flex-col items-center gap-2">
                                    <span className="text-slate-400 text-sm">SQUAD CODE:</span>
                                    <div className="flex items-center gap-2 w-full max-w-md">
                                        <code className="flex-1 bg-black p-2 rounded text-green-400 text-center">{myPeerId}</code>
                                        <button onClick={() => navigator.clipboard.writeText(myPeerId)} className="p-2 bg-slate-700 hover:bg-slate-600 rounded"><Copy size={18}/></button>
                                    </div>
                                </div>
                                <button 
                                    onClick={copyInviteLink}
                                    className="w-full py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-semibold flex items-center justify-center gap-2 transition-colors"
                                >
                                    <LinkIcon size={16}/> COPY INVITE LINK
                                </button>
                            </div>
                        )}

                        <div className="mb-8">
                            <h3 className="text-lg font-semibold mb-3 flex items-center gap-2 text-slate-300"><Users size={20}/> OPERATIVES ({renderedGameState.players.length}/4)</h3>
                            <div className="grid grid-cols-2 gap-4">
                            {renderedGameState.players.map(p => (
                                <div key={p.id} className="flex items-center gap-3 p-3 bg-slate-700 rounded-lg border border-slate-600">
                                <div className="w-8 h-8 rounded-full border-2 border-white shadow-sm" style={{ backgroundColor: p.color }}></div>
                                <span className="font-medium">{p.name} {p.isHost && '★'}</span>
                                </div>
                            ))}
                            {[...Array(4 - renderedGameState.players.length)].map((_, i) => (
                                <div key={i} className="flex items-center gap-3 p-3 bg-slate-800/50 rounded-lg border border-slate-700 border-dashed opacity-50">
                                <div className="w-8 h-8 rounded-full bg-slate-600"></div>
                                <span className="italic text-slate-500">Waiting for backup...</span>
                                </div>
                            ))}
                            </div>
                        </div>

                        {isHost ? (
                            <button 
                            onClick={startGame}
                            className="w-full py-4 bg-green-600 text-white rounded-xl font-bold text-xl hover:bg-green-500 shadow-lg shadow-green-900/50 transition-all"
                            >
                            START MISSION
                            </button>
                        ) : (
                            <div className="text-center py-4 text-slate-500 animate-pulse">
                            Waiting for leader to start...
                            </div>
                        )}
                        </div>
                    </div>
                );
            }

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-stone-950 p-2 select-none">
                    <GameCanvas gameState={renderedGameState} myPeerId={myPeerId} />
                    
                    {renderedGameState.gameStatus === 'GAME_OVER' && isHost && (
                        <div className="absolute bottom-10 pointer-events-auto animate-bounce">
                            <button 
                                onClick={restartGame}
                                className="flex items-center gap-2 px-8 py-4 bg-blue-600 hover:bg-blue-500 text-white text-xl font-bold rounded-full shadow-xl transition-transform hover:scale-105"
                            >
                                <RotateCcw size={24} /> RETRY MISSION
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
